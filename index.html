        <!DOCTYPE html>
        <html lang="de">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
            <title>Mein Golf Handicap - DGV/WHS</title>
            <meta name="apple-mobile-web-app-capable" content="yes">
            <meta name="apple-mobile-web-app-status-bar-style" content="default">
            <meta name="apple-mobile-web-app-title" content="Golf HCP">
            <meta name="theme-color" content="#28a745">
            <link rel="manifest" href="manifest.json">
            <link rel="apple-touch-icon" href="icon-512.png">
            <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
            <style>
                :root {
                    --color-bg-primary: #f8f9fa;
                    --color-surface: white;
                    --color-text-primary: #212529;
                    --color-text-secondary: #6c757d;
                    --color-primary: #28a745;
                    --color-primary-hover: #218838;
                    --color-accent: #007bff;
                    --color-danger: #dc3545;
                    --color-danger-hover: #c82333;
                    --color-warning: #ffc107;
                    --color-border: #dee2e6;
                    --color-secondary: #6c757d;
                    --color-secondary-hover: #5a6268;
                }
                
                @media (prefers-color-scheme: dark) {
                    :root {
                        --color-bg-primary: #212529;
                        --color-surface: #343a40;
                        --color-text-primary: #f8f9fa;
                        --color-text-secondary: #adb5bd;
                        --color-border: #495057;
                    }
                }
                
                * {
                    box-sizing: border-box;
                    margin: 0;
                    padding: 0;
                }
                
                body {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    background: var(--color-bg-primary);
                    color: var(--color-text-primary);
                    line-height: 1.6;
                    padding: 20px;
                    max-width: 1200px;
                    margin: 0 auto;
                }
                
                .container {
                    display: grid;
                    grid-template-columns: 340px 1fr;
                    gap: 20px;
                    min-height: 100vh;
                }
                
                @media (max-width: 768px) {
                    .container {
                        grid-template-columns: 1fr;
                        grid-auto-flow: dense;
                    }
                    
                    .main {
                        order: -1;
                    }
                }
                
                .sidebar {
                    background: var(--color-surface);
                    border-radius: 12px;
                    padding: 20px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
                    height: fit-content;
                }
                
                .main {
                    background: var(--color-surface);
                    border-radius: 12px;
                    padding: 20px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
                }
                
                h1 {
                    color: var(--color-primary);
                    margin: 0px 0 20px 0;
                    text-align: center;
                    font-size: 1.8em;
                    grid-column: 1/-1;
                }
                
                h2 {
                    color: var(--color-primary);
                    margin-bottom: 15px;
                    font-size: 1.3em;
                    font-weight: 600;
                }
                
                button {
                    background: var(--color-primary);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.2s;
                    width: 100%;
                    margin-bottom: 10px;
                }
                
                button:hover {
                    background: var(--color-primary-hover);
                    transform: translateY(-1px);
                }
                
                button.secondary {
                    background: var(--color-secondary);
                }
                
                button.secondary:hover {
                    background: var(--color-secondary-hover);
                }
                
                button.danger {
                    background: var(--color-danger);
                }
                
                button.danger:hover {
                    background: var(--color-danger-hover);
                }
                
                button.small {
                    width: auto;
                    padding: 6px 12px;
                    font-size: 12px;
                    margin: 0;
                }
                
                input, select {
                    width: 100%;
                    padding: 12px;
                    border: 2px solid var(--color-border);
                    border-radius: 8px;
                    margin-bottom: 10px;
                    font-size: 14px;
                    background: var(--color-bg-primary);
                    color: var(--color-text-primary);
                    min-height: 44px;
                    box-sizing: border-box;
                }
        
                input[type="date"] {
                    padding: 12px 8px 12px 12px;
                    -webkit-appearance: none;
                    -moz-appearance: none;
                    appearance: none;
                }
        
                input[type="date"]::-webkit-calendar-picker-indicator {
                    cursor: pointer;
                }
                
                input:focus, select:focus {
                    outline: none;
                    border-color: var(--color-accent);
                }
                
                .card {
                    background: var(--color-bg-primary);
                    border-radius: 8px;
                    padding: 15px;
                    margin-bottom: 15px;
                    border-left: 4px solid var(--color-primary);
                }
                
                .golfer-info {
                    background: linear-gradient(135deg, var(--color-primary), #20c997);
                    color: white;
                    text-align: center;
                    padding: 20px;
                    border-radius: 12px;
                    margin-bottom: 20px;
                }
                
                .hcp-display {
                    font-size: 3em;
                    font-weight: bold;
                    margin: 10px 0;
                }
                
                .round-list {
                    /* max-height: 500px; */
                    /* overflow-y: auto; */
                }
                
                .round-item {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 12px;
                    background: var(--color-bg-primary);
                    margin-bottom: 8px;
                    border-radius: 8px;
                }
                
                .stats-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                    gap: 15px;
                    margin: 20px 0;
                }
                
                .stat {
                    text-align: center;
                    padding: 15px;
                    background: var(--color-bg-primary);
                    border-radius: 12px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                }
                
                .stat-value {
                    font-size: 2.2em;
                    font-weight: bold;
                    color: var(--color-primary);
                    margin-bottom: 5px;
                }
                
                .setup-form {
                    background: var(--color-surface);
                    padding: 30px;
                    border-radius: 12px;
                    box-shadow: 0 8px 30px rgba(0,0,0,0.15);
                    max-width: 400px;
                    margin: 50px auto;
                    text-align: center;
                }
                
                .setup-form h2 {
                    color: var(--color-primary);
                    margin-bottom: 20px;
                }
                
                .setup-form input {
                    font-size: 16px;
                }
                
                .file-input-wrapper {
                    position: relative;
                    overflow: hidden;
                    display: inline-block;
                    width: 100%;
                    margin-bottom: 10px;
                }
        
                .file-input-wrapper button {
                    margin-bottom: 0;
                }
                
                .file-input-wrapper input[type=file] {
                    position: absolute;
                    left: -9999px;
                }
                
                .hcp-boxes {
                    display: flex;
                    gap: 10px;
                    margin-bottom: 20px;
                }
                
                .hcp-box {
                    flex: 1;
                    text-align: center;
                    padding: 15px;
                    color: white;
                    border-radius: 12px;
                    position: relative;
                    overflow: hidden;
                }
                
                .hcp-box.official {
                    background: linear-gradient(135deg, #28a745, #20c997);
                }
                
                .hcp-box.unofficial {
                    background: linear-gradient(135deg, #6c757d, #8c96a0);
                }
                
                .hcp-box-label {
                    font-size: 0.9em;
                    margin-bottom: 5px;
                }
                
                .hcp-box-value {
                    font-size: 1.6em;
                    font-weight: bold;
                }
                
        .advanced-stats {
          max-height: 0;
          overflow: hidden;
          opacity: 0;
          background: var(--color-bg-primary);
          border-radius: 12px;
        transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    opacity 0.3s ease, 
                    padding 0.3s ease,
                    margin 0.3s ease;
          margin-top: 0;
          margin-bottom: 0;
          padding: 0 20px;
        }
        
        .advanced-stats.active {
          max-height: 6000px;
          opacity: 1;
          margin-top: 20px;
          margin-bottom: 14px;
          padding: 20px;
        }
                
                .stat-row {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 12px;
                    margin-bottom: 8px;
                    background: var(--color-surface);
                    border-radius: 8px;
                    border-left: 3px solid var(--color-primary);
                }
                
                .stat-label {
                    font-weight: 600;
                    font-size: 0.85em;
                    color: var(--color-text-secondary);
                }
                
                .stat-data {
                    font-weight: bold;
                    color: var(--color-primary);
                    font-size: 0.85em;
                }
                
                .course-stats-item {
                    padding: 12px;
                    background: var(--color-surface);
                    border-radius: 8px;
                    margin-bottom: 8px;
                    border-left: 3px solid var(--color-accent);
                }
                
                .toggle-stats-btn {
                    background: var(--color-surface);
                    color: var(--color-text-primary);
                    border: none;
                    border-radius: 8px;
                    padding: 10px 16px;
                    font-size: 14px;
                    cursor: pointer;
                    transition: background 0.2s, transform 0.1s;
                    -webkit-tap-highlight-color: transparent;
                    user-select: none;
                }
                
                /* Desktop: Sichtbarer Hover */
                @media (hover: hover) and (pointer: fine) {
                    .toggle-stats-btn:hover {
                        background: #d0d4d9;
                    }
                }
                
                /* Desktop Dark Mode */
                @media (hover: hover) and (pointer: fine) and (prefers-color-scheme: dark) {
                    .toggle-stats-btn:hover {
                        background: #4a5460;
                    }
                }
                
                /* Desktop: Active Feedback */
                @media (hover: hover) and (pointer: fine) {
                    .toggle-stats-btn:active {
                        transform: scale(0.98);
                    }
                }
                
                /* Mobile: Kurzer Feedback-Flash */
                @media (hover: none) {
                    .toggle-stats-btn:hover,
                    .toggle-stats-btn:focus,
                    .toggle-stats-btn:focus-visible,
                    .toggle-stats-btn:focus-within {
                        background: var(--color-surface) !important;
                        outline: none !important;
                    }
                    
                    .toggle-stats-btn:active {
                        background: rgba(0, 0, 0, 0.05) !important;
                        transform: scale(0.98) !important;
                        transition: none !important;
                    }
                }
                
                /* Mobile Dark Mode */
                @media (hover: none) and (prefers-color-scheme: dark) {
                    .toggle-stats-btn:active {
                        background: rgba(255, 255, 255, 0.1) !important;
                    }
                }
        
                .add-round-btn {
                    display: none;
                    background: transparent;
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    padding: 0;
                    font-size: 24px;
                    font-weight: bold;
                    margin: 0 0 0 10px;
                    flex-shrink: 0;
                    color: #28a745;
                    border: none;
                    line-height: 1;
                    cursor: pointer;
                }
                
                .add-round-btn:hover {
                    background: transparent;
                    transform: scale(1.1);
                    color: #218838;
                }
                
                @media (max-width: 768px) {
                    .add-round-btn {
                        display: inline-block;
                    }
                }
        
                #handicapChart {
                    background: var(--color-bg-primary);
                    border-radius: 12px;
                    padding: 20px;
                    margin-top: 20px;
                    margin-bottom: 20px;
                    overflow-x: auto;
                }
                
                #hcpCanvas {
                    width: 100%;
                    height: auto;
                    max-width: 600px;
                    display: block;
                    margin: 0 auto;
                }
                
                @media (max-width: 768px) {
                    #handicapChart {
                        padding: 15px;
                        margin-top: 15px;
                    }
                    
                    #hcpCanvas {
                        max-width: 100%;
                        min-height: 200px;
                    }
                }
        
                .show-all-rounds-btn {
                    display: block;
                    width: 100%;
                    max-width: 300px;
                    margin: 15px auto;
                    padding: 10px 20px;
                    background: transparent;
                    color: var(--color-text-secondary);
                    border: 1px solid var(--color-border);
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 13px;
                    font-weight: 400;
                    transition: all 0.2s;
                    text-align: center;
                }
                
                .show-all-rounds-btn:hover {
                    background: var(--color-bg-primary);
                    border-color: var(--color-text-secondary);
                    color: var(--color-text-primary);
                    transform: translateY(-1px);
                }
        
                
                .rounds-hidden {
                    display: none;
                }
        
                input[type="radio"]:checked + span {
                    color: var(--color-primary);
                    font-weight: 600;
                }
                
                label:has(input[type="radio"]:checked) {
                    border-color: var(--color-primary) !important;
                    background: var(--color-surface) !important;
                }
                
                /* Bessere Farben f√ºr aktive Radio-Buttons */
                @media (prefers-color-scheme: light) {
                    label:has(input[type="radio"]:checked) {
                        background: rgba(40, 167, 69, 0.1) !important;
                        color: var(--color-primary);
                    }
                }
                
                @media (prefers-color-scheme: dark) {
                    label:has(input[type="radio"]:checked) {
                        background: rgba(40, 167, 69, 0.2) !important;
                    }
                }
        
        @media (min-width: 769px) {
            .desktop-break {
                display: block;
            }
            .mobile-bullet {
                display: none;
            }
            .course-info {
                white-space: pre-line;
            }
        }
        
        @media (max-width: 768px) {
            .desktop-break {
                display: none;
            }
            .mobile-bullet {
                display: inline;
            }
            .course-info {
                white-space: nowrap;
            }
        }
         
        
                .sparkline-container {
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    height: 60px;
                    opacity: 0.21;
                    pointer-events: none;
                }

                .sparkline-container svg {
                    width: 100%;
                    height: 100%;
                }

                .hcpi-link {
                    cursor: pointer;
                    transition: opacity 0.2s;
                    -webkit-tap-highlight-color: transparent;
                }

                .hcpi-link:hover {
                    opacity: 0.7;
                }

                .hcpi-sidebar-btn {
                    background: transparent;
                    color: var(--color-text-secondary);
                    border: 1px solid var(--color-border);
                    font-size: 13px;
                    font-weight: 400;
                    padding: 10px 20px;
                    transition: all 0.2s;
                    cursor: pointer;
                }

  .export-btn {
                    background: transparent;
                    color: var(--color-primary);
                    border: 1px solid var(--color-primary);
                    font-size: 13px;
                    font-weight: 400;
                    padding: 10px 20px;
                    transition: all 0.2s;
                    cursor: pointer;
                    -webkit-tap-highlight-color: transparent;
                }

                .danger-btn {
                    background: transparent;
                    color: var(--color-danger);
                    border: 1px solid var(--color-danger);
                    font-size: 13px;
                    font-weight: 400;
                    padding: 10px 20px;
                    transition: all 0.2s;
                    cursor: pointer;
                    -webkit-tap-highlight-color: transparent;
                }

                /* Desktop Hover */
                @media (hover: hover) and (pointer: fine) {
                    .hcpi-sidebar-btn:hover,
                    .export-btn:hover {
                        background: var(--color-bg-primary);
                        border-color: var(--color-text-secondary);
                        color: var(--color-text-primary);
                        transform: translateY(-1px);
                    }
                    .danger-btn:hover {
                        background: rgba(220, 53, 69, 0.1);
                        border-color: var(--color-danger);
                        color: var(--color-danger);
                        transform: translateY(-1px);
                    }
                }

                /* Mobile: kein klebriger Hover, kurzer Active-Flash */
                @media (hover: none) {
                    .hcpi-sidebar-btn:hover,
                    .hcpi-sidebar-btn:focus,
                    .export-btn:hover,
                    .export-btn:focus,
                    .danger-btn:hover,
                    .danger-btn:focus {
                        background: transparent !important;
                        outline: none !important;
                    }
                    .hcpi-sidebar-btn:active {
                        background: var(--color-bg-primary) !important;
                        transform: scale(0.98) !important;
                        transition: none !important;
                    }
                    .export-btn:active {
                        background: rgba(40, 167, 69, 0.1) !important;
                        transform: scale(0.98) !important;
                        transition: none !important;
                    }
                    .danger-btn:active {
                        background: rgba(220, 53, 69, 0.1) !important;
                        transform: scale(0.98) !important;
                        transition: none !important;
                    }
                }
        
                @media (max-width: 768px) {
                    .stats-grid {
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                    }
                }
                
                .sidebar #roundCourse,
                .sidebar #roundDate,
                .sidebar #roundStrokes,
                .sidebar #courseName {
                    display: block !important;
                    text-align: center !important;
                    text-align-last: center !important;
                }
        
                .sidebar #roundCourse option {
                  text-align: center !important;  /* Optionen im Dropdown */
                }
                
                @media (max-width: 768px) {
                  .sidebar #roundCourse,
                  .sidebar #roundDate,
                  .sidebar #roundStrokes,
                  .sidebar #courseName {
                    text-align: center !important;
                  }
                }
                
        /* Pfeile bei Number-Input entfernen */
        #roundStrokes::-webkit-outer-spin-button,
        #roundStrokes::-webkit-inner-spin-button,
        #coursePar::-webkit-outer-spin-button,
        #coursePar::-webkit-inner-spin-button,
        #courseCR::-webkit-outer-spin-button,
        #courseCR::-webkit-inner-spin-button,
        #courseSR::-webkit-outer-spin-button,
        #courseSR::-webkit-inner-spin-button,
        #startHcp::-webkit-outer-spin-button,
        #startHcp::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* F√ºr Firefox */
        #roundStrokes,
        #coursePar,
        #courseCR,
        #courseSR,
        #startHcp {
            -moz-appearance: textfield;
        }
        
        /* Desktop: Hover zeigt Buttons */
        @media (min-width: 769px) {
          .round-item .round-actions,
          .course-item .course-actions {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            flex-direction: column;
            gap: 6px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s ease;
          }
          
          /* Buttons bei Hover anzeigen */
          .round-item:hover .round-actions,
          .course-item:hover .course-actions {
            display: flex;
            opacity: 1;
          }
          
          /* Par/Netto nach links schieben bei Hover */
          .round-scores {
            transition: margin-right 0.2s ease;
          }
          
          .round-item:hover .round-scores {
            margin-right: 70px;
          }
          
          .round-item,
          .course-item {
            position: relative;
          }
        }
        
        /* Mobile: Click/Tap zeigt Buttons */
        @media (max-width: 768px) {
          .round-item {
            cursor: pointer;
            position: relative;
          }
          
          .round-item .round-actions,
          .course-item .course-actions {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            flex-direction: column;
            gap: 6px;
            z-index: 10;
          }
          
          .round-item.active .round-actions,
          .course-item.active .course-actions {
            display: flex;
          }
          
          .round-scores {
            transition: margin-right 0.2s ease;
            margin-right: 0;
          }
          
          .round-item.active .round-scores {
            margin-right: 70px;
          }
          
          .course-item {
            cursor: pointer;
            position: relative;
          }
        }
        
        
        </style>
        
        </head>
        <body tabindex="-1">
            <div id="setupScreen" class="setup-form">
                <h2>Einmalige Einrichtung</h2>
                <p style="margin-bottom: 20px;">Deine pers√∂nlichen Golf-Daten:</p>
                <input id="myName" placeholder="Dein Name" required>
                <input id="myClub" placeholder="Dein Club (optional)">
                <input id="startHcp" type="number" step="0.1" inputmode="decimal" placeholder="Aktuelles Handicap (z.B. 19.5)" required>
                <button onclick="setupComplete()">‚úÖ Einrichtung abschlie√üen</button>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--color-border);">
                    <input type="file" id="setupImportFile" accept=".json" onchange="setupImportData(event)" style="display: none;">
                    <a href="#" onclick="document.getElementById('setupImportFile').click(); return false;" style="color: var(--color-text-secondary); font-size: 13px; text-decoration: none;">
                        üìÅ Oder bestehende Daten importieren
                    </a>
                </div>
            </div>
            
            <div id="mainApp" style="display:none;">
                <div class="container">
                    <div class="sidebar">
                        
                        <h2>Neue Runde</h2>
                        
                        <!-- 9/18 L√∂cher -->
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <label style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; cursor: pointer; padding: 0 12px; background: var(--color-bg-primary); border-radius: 8px; border: 2px solid transparent; height: 46px; box-sizing: border-box;" id="roundHoles9Label">
                                <input type="radio" name="roundHoles" id="roundHoles9" value="9" style="width: auto; margin: 0;" onchange="filterCoursesByHoles()">
                                <span style="font-weight: 500;">9 L√∂cher</span>
                            </label>
                            <label style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; cursor: pointer; padding: 0 12px; background: var(--color-bg-primary); border-radius: 8px; border: 2px solid transparent; height: 46px; box-sizing: border-box;" id="roundHoles18Label">
                                <input type="radio" name="roundHoles" id="roundHoles18" value="18" checked style="width: auto; margin: 0;" onchange="filterCoursesByHoles()">
                                <span style="font-weight: 500;">18 L√∂cher</span>
                            </label>
                        </div>
        
                        <input id="roundDate" type="date" style="height: 46px; margin-bottom: 10px; text-align: center !important; padding: 12px;">
                        <select id="roundCourse" style="height: 46px; margin-bottom: 10px;"></select>
                        
         <div style="position: relative; margin-bottom: 10px;">
            <input id="roundStrokes" type="number" inputmode="numeric" placeholder="Schl√§ge eingeben" 
                   style="height: 46px; 
                          width: 100%; 
                          text-align: center; 
                          padding: 12px;
                          -moz-appearance: textfield;">
            <span id="strokesSuffix" 
                  style="position: absolute; 
                         left: 50%; 
                         top: 50%; 
                         transform: translate(-50%, -50%); 
                         color: var(--color-text-primary); 
                         font-size: 16px; 
                         pointer-events: none; 
                         display: none; 
                         white-space: nowrap;">
            </span>
        </div>
        
        
                        
                        <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; margin-bottom: 10px;">
                            <input type="checkbox" id="roundOfficial" style="width: 16px; height: 20px; margin: 0; accent-color: var(--color-primary);">
                            <span style="font-weight: 400; font-size: 14px;">HCPI wirksam</span>
                        </label>
                        
                        <button onclick="saveRound()">Runde speichern</button>
        
                        
                        <h2 style="margin-top: 30px;">Neuer Platz</h2>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <label style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; cursor: pointer; padding: 0 12px; background: var(--color-bg-primary); border-radius: 8px; border: 2px solid transparent; height: 46px; box-sizing: border-box;" id="courseHoles9Label">
                                <input type="radio" name="courseHoles" id="courseHoles9" value="9" style="width: auto; margin: 0;">
                                <span style="font-weight: 500;">9 L√∂cher</span>
                            </label>
                            <label style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; cursor: pointer; padding: 0 12px; background: var(--color-bg-primary); border-radius: 8px; border: 2px solid transparent; height: 46px; box-sizing: border-box;" id="courseHoles18Label">
                                <input type="radio" name="courseHoles" id="courseHoles18" value="18" checked style="width: auto; margin: 0;">
                                <span style="font-weight: 500;">18 L√∂cher</span>
                            </label>
                        </div>
                        <div style="text-align: center;">
                              <input id="courseName" placeholder="Platznamen angeben">
                        </div>
                        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                            <input id="coursePar" type="number" inputmode="numeric" placeholder="Par" style="flex: 1; min-width: 0; text-align: center;">
                            <input id="courseCR" type="number" step="0.1" inputmode="decimal" placeholder="CR" style="flex: 1; min-width: 0; text-align: center;">
                            <input id="courseSR" type="number" inputmode="numeric" placeholder="SR" style="flex: 1; min-width: 0; text-align: center;">
                        </div>
                        <button onclick="addCourse()">Platz speichern</button>
        
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 30px;">
                        
                            <h2 style="margin: 0;" id="courseManageTitle">Pl√§tze verwalten</h2>
                        <button id="collapseCoursesBtn" class="small" onclick="toggleAllCourses()" style="display: none; background: transparent; color: var(--color-text-secondary); font-size: 20px; font-weight: bold; padding: 0 8px; line-height: 1; border: none;">‚àí</button>
                        </div>
                        <div id="courseManageList" style="margin-top:15px;"></div>
                        <button id="showAllCoursesBtn" class="show-all-rounds-btn" onclick="toggleAllCourses()" style="display: none; margin-top: 10px; font-size: 12px; padding: 8px;">Alle Pl√§tze anzeigen</button>
                        
                        <h2 style="margin-top: 30px;">Daten-Verwaltung</h2>
                        <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; margin-bottom: 10px;">
                    <input type="checkbox" id="autoFocusToggle" onchange="toggleAutoFocus()" style="width: 16px; height: 20px; margin: 0; accent-color: var(--color-primary);">
                            <span style="font-weight: 400; font-size: 14px;">Auto-Fokus "Schl√§ge eingeben"</span>
                        </label>
        
                        <button class="export-btn" onclick="exportData()">üíæ Daten exportieren (JSON)</button>
                        <div class="file-input-wrapper" style="margin-bottom: 0;">
                        
                        <input type="file" id="importFile" accept=".json" onchange="importData(event)">
                        <button class="hcpi-sidebar-btn" onclick="document.getElementById('importFile').click()">üìÅ Daten importieren</button>
                        </div>
                        
                        <button class="hcpi-sidebar-btn" onclick="showEditProfile()">üë§ Profil bearbeiten</button>
                        <button class="hcpi-sidebar-btn" onclick="showHandicapCalculation()">üìã HCPI-Berechnung anzeigen</button>
                        <button class="hcpi-sidebar-btn" onclick="manualRecalculate()">üîÑ Handicap neu berechnen</button>
                        <button class="danger-btn" onclick="clearData()">üóëÔ∏è Alles l√∂schen</button>
                        </div>
                    
                    <div class="main">
                        <div style="text-align: center; margin-bottom: 5px;">
                            <h1 style="font-size: 0.85em; margin-bottom: 5px; margin-top: 0px; color: var(--color-text-secondary);">
                                <span id="golferNameDisplay">-</span> - <span id="golferClubDisplay">-</span>
                            </h1>
                        </div>
                        
                        <div class="hcp-boxes">
                            <div class="hcp-box official">
                                <div class="hcp-box-label">üèÜ HCP (gewertet)</div>
                                <div class="hcp-box-value" id="officialHcp">-</div>
                                <div class="sparkline-container" id="sparklineOfficial"></div>
                            </div>
                            <div class="hcp-box unofficial">
                                <div class="hcp-box-label">üèåÔ∏è HCP (gesamt)</div>
                                <div class="hcp-box-value" id="unofficialHcp">-</div>
                                <div class="sparkline-container" id="sparklineUnofficial"></div>
                            </div>
                        </div>
                        
                        <div class="stats-grid" style="grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
                            
                            <!-- Kompakte Runden-Z√§hler -->
                            <div class="hcpi-link" onclick="showHandicapCalculation()" style="grid-column: 1 / -1; text-align: center; font-size: 0.85em; color: var(--color-text-secondary); margin-top: -14px; margin-bottom: -2px; padding: 6px 0;">
                                <span id="totalRounds">0</span> Runden (<span id="officialRounds">0</span> gewertete ‚òÜ)
                            </div>

                                <!-- Kachel 1: √ò √ºber Par -->
                                <div class="stat">
                                    <div style="font-size: 1.4em; font-weight: bold; color: var(--color-text-secondary);" id="avgOverPar">-</div>
                                    <div style="font-size: 0.75em; color: var(--color-text-secondary);">√ò zu Par (letzte 20)</div>
                                </div>

                            <!-- Kachel 2: Netto √ò letzte 5 -->
                            <div class="stat">
                                <div class="stat-value" id="formNettoLast5" style="font-size: 1.4em;">-</div>
                                <div style="font-size: 0.75em; margin-top: 3px; color: var(--color-text-secondary);" id="formNettoTrend">-</div>
                                <div style="font-size: 0.75em; color: var(--color-text-secondary);">Netto (√ò letzte 5)</div>
                            </div>

                            <!-- Kachel 3: 30-Tage-Trend -->
                            <div class="stat">
                                <div style="font-size: 1.4em; font-weight: bold;" id="trend30Days">-</div>
                                <div style="font-size: 0.75em; margin-top: 3px; color: var(--color-text-secondary);" id="trend30DaysLabel">HCP letzte 30 Tage</div>
                            </div>

                            <!-- Kachel 4: Runden im HCP + zu Par -->
                            <div class="stat">
                                <div style="font-size: 1.4em; font-weight: bold; color: var(--color-accent);" id="percentInHcpLast10">-</div>
                                <div style="font-size: 0.75em; color: var(--color-text-secondary);">Runden im HCP (letzte 10)</div>
                                <div style="font-size: 0.75em; color: var(--color-text-secondary);" id="avgToParLast10">-</div>
                            </div>

                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h2 style="margin: 0;">Letzte Runden</h2>
                            <div style="display: flex; align-items: center;">
                                <button class="toggle-stats-btn small" onclick="toggleAdvancedStats()">
                                    üìä Erweiterte Statistiken
                                </button>
                                <button class="add-round-btn" onclick="scrollToAddRound()" title="Neue Runde erfassen">
                                    +
                                </button>
                            </div>
                        </div>
        
                        
                        <div id="advancedStats" class="advanced-stats">
                            <h3 style="color: var(--color-primary); margin-bottom: 15px;">üìä Erweiterte Statistiken</h3>
                                
                                <div style="background: linear-gradient(135deg, var(--color-primary), #20c997); color: white; padding: 15px; border-radius: 12px; margin-bottom: 20px; text-align: center;">
                <div style="font-size: 0.8em; opacity: 0.9; margin-bottom: 5px;">üéØ N√ÑCHSTES ZIEL</div>
                <div id="nextGoal" style="font-size: 0.85em; font-weight: 600;">-</div>
                        </div>
                        
                            <div style="margin-bottom: 20px;">
                                <h4 style="color: var(--color-text-secondary); font-size: 0.9em; margin-bottom: 10px;">ALLGEMEINE STATISTIK</h4>
                                <div id="generalStats"></div>
                            </div>
                            
                        <h4 style="color: var(--color-text-secondary); font-size: 0.9em; margin-bottom: 10px">PLATZ-STATISTIK</h4>
                            <div id="courseStats"></div>
                        <button id="showAllCoursesStatsBtn" class="show-all-rounds-btn" onclick="toggleAllCoursesStats()" style="display: none; margin-top: 10px;">Alle Pl√§tze anzeigen</button>
        
                            
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: var(--color-text-secondary); font-size: 0.9em; margin: 0;">TREND-ANALYSE</h4>
                                <button class="small" onclick="toggleAdvancedStats()" style="background: transparent; color: var(--color-text-secondary); font-size: 18px; font-weight: bold; padding: 0 8px; line-height: 1; border: none; cursor: pointer; -webkit-tap-highlight-color: transparent;">^</button>
                            </div>
                            <div>
                                <div id="trendStats"></div>
                            </div>

                            <!-- Graph innerhalb Erweiterte Statistiken -->
                            <div id="handicapChartWrapper" style="display: none; text-align: center; margin-top: 20px;">
                                <h4 style="color: var(--color-text-secondary); font-size: 0.9em; margin-bottom: 10px;">HANDICAP-ENTWICKLUNG</h4>
                                <canvas id="hcpCanvas"></canvas>
                                <div style="margin-top:10px;font-size:13px;color:var(--color-text-secondary);">
                                    Letzte 10 Runden
                                </div>
                            </div>
                        </div>
        

                        <div class="round-list" id="roundList"></div>
                        
                        <button id="showAllRoundsBtn" class="show-all-rounds-btn" onclick="toggleAllRounds()" style="display: none;">
                            Alle Runden anzeigen
                        </button>
        
                        </div>
                    </div>
                </div>
            
            <script>
                let myGolfer = null;
                let courses = [];
        
                    // ID-Generator verhindert Kollisionen bei schnellem Speichern
            let lastGeneratedId = 0;
            
            function generateUniqueId() {
                const timestamp = Date.now();
                if (timestamp <= lastGeneratedId) {
                    lastGeneratedId++;
                } else {
                    lastGeneratedId = timestamp;
                }
                return lastGeneratedId.toString();
            }
        
        // Standardkurse f√ºr neue Installationen
        const DEFAULT_COURSES = [
          {
            "id": "1770302839387",
            "name": "GolfRange Frankfurt",
            "cr": 30,
            "sr": 111,
            "holes": 9,
            "par": 31
          },
          {
            "id": "1770303312187",
            "name": "GolfRange Frankfurt",
            "cr": 60,
            "sr": 112,
            "holes": 18,
            "par": 62
          },
          {
            "id": "1770468971064",
            "name": "Bachgrund - Nessie",
            "cr": 71.6,
            "sr": 136,
            "holes": 18,
            "par": 72
          },
          {
            "id": "1770469087435",
            "name": "Bachgrund - Happy Luck",
            "cr": 68.6,
            "sr": 123,
            "holes": 18,
            "par": 70
          },
          {
            "id": "1770469105548",
            "name": "Bachgrund - Happy Luck",
            "cr": 34.4,
            "sr": 121,
            "holes": 9,
            "par": 35
          },
          {
            "id": "1770469150963",
            "name": "Gernsheim - Parkland",
            "cr": 68.9,
            "sr": 120,
            "holes": 18,
            "par": 72
          },
          {
            "id": "1770469188250",
            "name": "Gernsheim - Lufthansa",
            "cr": 65.6,
            "sr": 115,
            "holes": 18,
            "par": 70
          },
          {
            "id": "1770469209565",
            "name": "Kiawah Riedstadt",
            "cr": 71.3,
            "sr": 124,
            "holes": 18,
            "par": 72
          },
          {
            "id": "1770469236167",
            "name": "Golfpark Trages",
            "cr": 70.4,
            "sr": 135,
            "holes": 18,
            "par": 72
          },
          {
            "id": "1770469253847",
            "name": "Golfpark Biblis - B+C",
            "cr": 72.9,
            "sr": 139,
            "holes": 18,
            "par": 75
          },
          {
            "id": "1770469276987",
            "name": "Golfpark Biblis - A+C",
            "cr": 71.9,
            "sr": 136,
            "holes": 18,
            "par": 74
          },
          {
            "id": "1770469295114",
            "name": "Golfpark Biblis - A+B",
            "cr": 71.8,
            "sr": 136,
            "holes": 18,
            "par": 73
          },
          {
            "id": "1770469322698",
            "name": "Friedberg - S√ºdkurs",
            "cr": 72,
            "sr": 127,
            "holes": 18,
            "par": 72
          },
          {
            "id": "1770469346562",
            "name": "Friedberg - Nordkurs",
            "cr": 30.9,
            "sr": 109,
            "holes": 9,
            "par": 32
          },
          {
            "id": "1770469374980",
            "name": "Altenstadt A/B",
            "cr": 71,
            "sr": 127,
            "holes": 18,
            "par": 71
          },
          {
            "id": "1770469483078",
            "name": "Altenstadt C",
            "cr": 34.2,
            "sr": 129,
            "holes": 9,
            "par": 35
          },
          {
            "id": "1770469512596",
            "name": "Bad Vilbel - Lindenhof",
            "cr": 71.6,
            "sr": 127,
            "holes": 18,
            "par": 72
          },
          {
            "id": "1770469527746",
            "name": "GC Neuhof - Parkland",
            "cr": 71.8,
            "sr": 138,
            "holes": 18,
            "par": 72
          },
          {
            "id": "1770469593446",
            "name": "GC Neuhof - Skyline",
            "cr": 36.5,
            "sr": 126,
            "holes": 9,
            "par": 36
          },
          {
            "id": "1770469614562",
            "name": "Licher GC",
            "cr": 71.8,
            "sr": 130,
            "holes": 18,
            "par": 72
          }
        ];
                
                function init() {
                    myGolfer = null;
                    courses = []; 
                    loadData();
                    checkSetup();
                    loadAutoFocusSetting();
                }
        
                function setupComplete() {
                    const name = document.getElementById('myName').value.trim();
                    const club = document.getElementById('myClub').value.trim();
                    const startHcpStr = document.getElementById('startHcp').value; // Hole den String zuerst
                    
                    // Trimmen und Komma durch Punkt ersetzen (wichtig f√ºr deutsche Eingabe)
                    const startHcp = parseFloat(startHcpStr.replace(',', '.'));
                
                    // Detaillierte Fehlerpr√ºfung mit Alert
                    if (!name) {
                        return alert('Bitte einen Namen eingeben!');
                    }
                    
                    if (isNaN(startHcp)) {
                        return alert('Bitte ein g√ºltiges Handicap eingeben (z.B. 19.5 oder 19,5)!');
                    }
                    
                    if (startHcp < -5 || startHcp > 54) {
                        return alert('Handicap muss zwischen -5 und 54 liegen!');
                    }
                
                    if (!myGolfer) {
                        // Falls myGolfer noch null ist (Sicherheitsnetz)
                        myGolfer = {};
                    }
                
                    // Profil korrekt erstellen
                    myGolfer.id = 'me';
                    myGolfer.name = name;
                    myGolfer.club = club || '';
                    myGolfer.handicapIndex = startHcp;
                    myGolfer.lowestHandicapIndex = startHcp;
                        myGolfer.unofficialHandicap = startHcp;
                        myGolfer.rounds = [];
                        myGolfer.startHcp = startHcp;
                        myGolfer.hcpHistory = [{ date: new Date().toISOString(), hcp: startHcp }];
                        myGolfer.created = new Date().toISOString();
                
                    // Speichern
                    localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
                    
                    // UI Update ausl√∂sen
                    checkSetup();
                }
        
                function checkSetup() {
                    try {
                        const stored = localStorage.getItem('myGolfer');
                        myGolfer = stored ? JSON.parse(stored) : null;
                    } catch (err) {
                        console.error('Fehler beim Laden der Daten:', err);
                        myGolfer = null;
                    }
                    
                    if (myGolfer) {
                        try {
                            // Sicherstellen dass rounds Array existiert
                            if (!myGolfer.rounds) {
                                myGolfer.rounds = [];
                            }
                            
                            // üîß NEU: Pr√ºfe dass rounds wirklich ein Array ist
                            if (!Array.isArray(myGolfer.rounds)) {
                                console.warn('rounds ist kein Array, korrigiere...');
                                myGolfer.rounds = [];
                            }
                            
                            // Normalisiere nur wenn n√∂tig UND Runden vorhanden
                            if (myGolfer.rounds.length > 0) {
                                const needsNormalization = myGolfer.rounds.some(r => typeof r.id !== 'string');
                                
                                if (needsNormalization) {
                                    myGolfer.rounds = myGolfer.rounds.map(r => ({
                                        ...r,
                                        id: String(r.id)
                                    }));
                                    localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
                                }
                            }
                        } catch (normErr) {
                            console.error('Warnung: ID-Normalisierung fehlgeschlagen', normErr);
                        }
                    }
                    
                    if (!myGolfer) {
                        document.getElementById('setupScreen').style.display = 'block';
                        document.getElementById('mainApp').style.display = 'none';
                    } else {
                        document.getElementById('setupScreen').style.display = 'none';
                        document.getElementById('mainApp').style.display = 'block';
                        updateUI();
                        document.getElementById('roundDate').valueAsDate = new Date();
                    }
                }
        
                
                function updateUI() {
                    if (!myGolfer) return;
                    
                    document.getElementById('golferNameDisplay').textContent = myGolfer.name;
                    document.getElementById('golferClubDisplay').textContent = myGolfer.club || 'Unabh√§ngiger Golfer';
                    
                    const rounds = myGolfer.rounds || [];
                    const officialRounds = rounds.filter(r => r.official !== false);
                    
                    document.getElementById('totalRounds').textContent = rounds.length;
                    document.getElementById('officialRounds').textContent = officialRounds.length;
                    document.getElementById('officialHcp').textContent = myGolfer.handicapIndex.toFixed(1);
                    document.getElementById('unofficialHcp').textContent = (myGolfer.unofficialHandicap || myGolfer.handicapIndex).toFixed(1);
                    
                    if (rounds.length > 0) {
        const last5 = rounds.slice(-5);
        
        // === KACHEL 1: NETTO √ò (Letzte 5) ===
        if (last5.length > 0) {
            const nettoDeltas = last5.map(r => {
                const course = courses.find(c => c.name === r.course && c.holes === r.holes);
                const par = course ? course.par : (r.holes === 9 ? 36 : 72);
                const netto = r.strokes - (par + (r.courseHandicap || 0));
                return r.holes === 9 ? netto * 2 : netto;
            });
            const avgNettoDelta = nettoDeltas.reduce((a,b) => a + b, 0) / last5.length;
            
            let nettoText, nettoColor;
            if (avgNettoDelta <= -0.5) {
                nettoText = `${avgNettoDelta.toFixed(1)}`;
                nettoColor = 'var(--color-primary)';
            } else if (avgNettoDelta >= 0.5) {
                nettoText = `+${avgNettoDelta.toFixed(1)}`;
                nettoColor = 'var(--color-danger)';
            } else {
                nettoText = '¬±0';
                nettoColor = 'var(--color-text-secondary)';
            }
            document.getElementById('formNettoLast5').textContent = nettoText;
            document.getElementById('formNettoLast5').style.color = nettoColor;
            
            // Trend: letzte 5 vs. letzte 20
            const recent = rounds.slice(-20);
            const allNettoDeltas = recent.map(r => {
                const course = courses.find(c => c.name === r.course && c.holes === r.holes);
                const par = course ? course.par : (r.holes === 9 ? 36 : 72);
                const netto = r.strokes - (par + (r.courseHandicap || 0));
                return r.holes === 9 ? netto * 2 : netto;
            });
            const avgNettoAll = allNettoDeltas.reduce((a,b) => a + b, 0) / recent.length;
            const trendDiff = avgNettoDelta - avgNettoAll;
            
            let trendText, trendColor;
            if (trendDiff <= -1.0) {
                trendText = 'üìà Besser als Schnitt';
                trendColor = 'var(--color-primary)';
            } else if (trendDiff >= 1.0) {
                trendText = 'üìâ Unter Schnitt';
                trendColor = 'var(--color-danger)';
            } else {
                trendText = '‚û°Ô∏è Im Schnitt';
                trendColor = 'var(--color-text-secondary)';
            }
            document.getElementById('formNettoTrend').textContent = trendText;
            document.getElementById('formNettoTrend').style.color = trendColor;
        } else {
            document.getElementById('formNettoLast5').textContent = '-';
            document.getElementById('formNettoTrend').textContent = '-';
        }
        
        // === KACHEL 2: 30-TAGE-TREND ===
        const hcpHistory = myGolfer.hcpHistory || [];
        if (hcpHistory.length >= 2) {
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            const oldEntries = hcpHistory.filter(h => new Date(h.date) <= thirtyDaysAgo);
            const hcp30Ago = oldEntries.length > 0 ? oldEntries[oldEntries.length - 1].hcp : myGolfer.startHcp;
            const hcpNow = myGolfer.handicapIndex;
            const change = (hcpNow - hcp30Ago).toFixed(1);
            
            const trendEl = document.getElementById('trend30Days');
            if (parseFloat(change) < -0.1) {
                trendEl.textContent = `${change}`;
                trendEl.style.color = 'var(--color-primary)';
            } else if (parseFloat(change) > 0.1) {
                trendEl.textContent = `+${change}`;
                trendEl.style.color = 'var(--color-danger)';
            } else {
                trendEl.textContent = '¬±0';
                trendEl.style.color = 'var(--color-text-secondary)';
            }
        } else {
            document.getElementById('trend30Days').textContent = '-';
            document.getElementById('trend30Days').style.color = 'var(--color-text-secondary)';
        }
        
        // === KACHEL 3: RUNDEN IM HCP (Letzte 10) + √ò zu Par ===
        const last10 = rounds.slice(-10);
        if (last10.length > 0) {
            const roundsUnderHcp = last10.filter(r => r.scoreDifferential <= r.playingHcp).length;
            const percentInHcp = Math.round((roundsUnderHcp / last10.length) * 100);
            document.getElementById('percentInHcpLast10').textContent = `${percentInHcp}%`;
            
            // √ò zu Par (letzte 10, normalisiert auf 18L)
            const toParVals = last10.map(r => {
                const c = courses.find(c => c.name === r.course && c.holes === r.holes);
                const par = c ? c.par : (r.holes === 9 ? 36 : 72);
                const toPar = r.strokes - par;
                return r.holes === 9 ? toPar * 2 : toPar;
            });
            const avgToPar = toParVals.reduce((a, b) => a + b, 0) / last10.length;
            const avgToParRound = Math.round(avgToPar);
            let toParDisplay;
            if (avgToParRound === 0) {
                toParDisplay = '√ò Even Par';
            } else if (avgToParRound > 0) {
                toParDisplay = `√ò +${avgToParRound} zu Par`;
            } else {
                toParDisplay = `√ò ${avgToParRound} zu Par`;
            }
            document.getElementById('avgToParLast10').textContent = toParDisplay;
        } else {
            document.getElementById('percentInHcpLast10').textContent = '-';
            document.getElementById('avgToParLast10').textContent = '-';
        }

// === KACHEL 4: √ò √úBER PAR (letzte 20, getrennt 9/18L) ===
const recent20All = rounds.slice(-20);
if (recent20All.length > 0) {
    const r18 = recent20All.filter(r => r.holes === 18);
    const r9 = recent20All.filter(r => r.holes === 9);
    
    const avg18 = r18.length > 0 
        ? Math.round(r18.reduce((s, r) => {
            const c = courses.find(c => c.name === r.course && c.holes === r.holes);
            const par = c ? c.par : 72;
            return s + (r.strokes - par);
        }, 0) / r18.length) : null;
    
    const avg9 = r9.length > 0 
        ? Math.round(r9.reduce((s, r) => {
            const c = courses.find(c => c.name === r.course && c.holes === r.holes);
            const par = c ? c.par : 36;
            return s + (r.strokes - par);
        }, 0) / r9.length) : null;
    
    let overParText = '';
    if (avg18 !== null && avg9 !== null) {
        const t18 = avg18 > 0 ? `+${avg18}` : avg18 === 0 ? 'Even' : `${avg18}`;
        const t9 = avg9 > 0 ? `+${avg9}` : avg9 === 0 ? 'Even' : `${avg9}`;
        overParText = `${t18} (18L)\n${t9} (9L)`;
    } else if (avg18 !== null) {
        overParText = avg18 > 0 ? `+${avg18}` : avg18 === 0 ? 'Even' : `${avg18}`;
    } else {
        overParText = avg9 > 0 ? `+${avg9}` : avg9 === 0 ? 'Even' : `${avg9}`;
    }
    
    const el = document.getElementById('avgOverPar');
    el.style.whiteSpace = 'pre-line';
    el.textContent = overParText;
} else {
    document.getElementById('avgOverPar').textContent = '-';
}
                        
        } else {
                        document.getElementById('formNettoLast5').textContent = '-';
                        document.getElementById('formNettoTrend').textContent = '-';
                        document.getElementById('trend30Days').textContent = '-';
                        document.getElementById('percentInHcpLast10').textContent = '-';
                        document.getElementById('avgToParLast10').textContent = '-';
                        document.getElementById('avgOverPar').textContent = '-';
                    }
                    
                    renderCourses();
                    renderRounds();
                    renderSparklines();
                    
                    // Chart: nur innerhalb Erweiterte Statistiken rendern wenn offen
                    const chartWrapper = document.getElementById('handicapChartWrapper');
                    if (rounds.length >= 2) {
                        chartWrapper.style.display = 'block';
                        if (document.getElementById('advancedStats').classList.contains('active')) {
                            renderChart();
                        }
                    } else {
                        chartWrapper.style.display = 'none';
                    }
                }
        
                
        function renderSparklines() {
            const rounds = myGolfer.rounds || [];
            if (rounds.length < 2) {
                document.getElementById('sparklineOfficial').innerHTML = '';
                document.getElementById('sparklineUnofficial').innerHTML = '';
                return;
            }

            function buildSparklineSVG(values, color) {
                if (values.length < 2) return '';
                const min = Math.min(...values);
                const max = Math.max(...values);
                const range = max - min || 1;
                const w = 100;
                const h = 25;
                const pad = 2;
                const points = values.map((v, i) => {
                    const x = pad + (i / (values.length - 1)) * (w - 2 * pad);

                    const y = pad + ((max - v) / range) * (h - 2 * pad);
                        
                    return `${x},${y}`;
                }).join(' ');
                return `<svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none"><polyline points="${points}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
            }

            // Offizielle HCP-History
            const hcpHistory = myGolfer.hcpHistory || [];
            const officialVals = hcpHistory.slice(-10).map(h => h.hcp);
            document.getElementById('sparklineOfficial').innerHTML = buildSparklineSVG(officialVals, 'rgba(255,255,255,0.8)');

            // Inoffizielle: berechne aus allen Runden
            const last10Rounds = rounds.slice(-10);
            const unofficialVals = [];
            for (let i = 0; i < last10Rounds.length; i++) {
                const roundDate = new Date(last10Rounds[i].date);
                const tempAll = rounds.filter(r => new Date(r.date) <= roundDate)
                    .slice(-20)
                    .map(r => r.scoreDifferential)
                    .sort((a, b) => a - b);
                if (tempAll.length < 3) {
                    unofficialVals.push(myGolfer.startHcp);
                } else {
                    const { numCounted, adjustment } = getWHSParameters(tempAll.length);
                    let hcp = tempAll.slice(0, numCounted).reduce((a, b) => a + b, 0) / numCounted + adjustment;
                    hcp = Math.round(hcp * 10) / 10;
                    const lowestHcp = getLowestHcpLast12Months(last10Rounds[i].date, myGolfer.hcpHistory || [], myGolfer.startHcp);
                    hcp = applyCaps(hcp, lowestHcp);
                    unofficialVals.push(hcp);
                }
            }
            document.getElementById('sparklineUnofficial').innerHTML = buildSparklineSVG(unofficialVals, 'rgba(255,255,255,0.7)');
        }

                function loadData() {
            try {
                const data = localStorage.getItem('courses');
                if (data) {
                    courses = JSON.parse(data);
                } else {
                    // Erste Installation: Lade Standardkurse
                    courses = [...DEFAULT_COURSES];
                }
                
                // üîß Pr√ºfe ob Normalisierung n√∂tig ist
                const needsNormalization = courses.some(c => typeof c.id !== 'string');
                
                if (needsNormalization) {
                    courses = courses.map(c => ({
                        ...c,
                        id: String(c.id)
                    }));
                    saveCourses(); // Nur speichern wenn ge√§ndert
                }
                
            } catch (err) {
                console.error('Fehler beim Laden der Pl√§tze:', err);
                
                // üîß Notfall: Lade DEFAULT_COURSES und normalisiere
                courses = [...DEFAULT_COURSES].map(c => ({
                    ...c,
                    id: String(c.id)
                }));
                
                // üîß WICHTIG: Speichere die korrekten Daten, um die Fehler-Schleife zu brechen!
                saveCourses();
            }
        }
        
                
                function saveCourses() {
                    localStorage.setItem('courses', JSON.stringify(courses));
                }
        
                function calculateCourseHandicap(handicapIndex, slopeRating, courseRating, par) {
                    // WHS-Formel: Course Handicap = HCP Index √ó (SR / 113) + (CR - Par)
                    return Math.round(handicapIndex * (slopeRating / 113) + (courseRating - par));
                }
                
                function renderCourses() {
                    filterCoursesByHoles();
                
                    const title = document.getElementById('courseManageTitle');
                    if (title) {
                        title.textContent = `Pl√§tze verwalten (${courses.length})`;
                    }
                    
                    const manageList = document.getElementById('courseManageList');
                    if (manageList) {
                        if (courses.length === 0) {
                            manageList.innerHTML = '<div style="text-align:center;color:var(--color-text-secondary);padding:20px;font-size:14px;">Keine Pl√§tze angelegt</div>';
                            document.getElementById('showAllCoursesBtn').style.display = 'none';
                        } else {
                            // Button nur anzeigen wenn mehr als 3 Pl√§tze
                            const showAllCoursesBtn = document.getElementById('showAllCoursesBtn');
                            const showAll = window.showAllCourses || false;
                            const collapseBtn = document.getElementById('collapseCoursesBtn');
                            if (courses.length > 3) {
                                showAllCoursesBtn.style.display = 'block';
                                showAllCoursesBtn.textContent = showAll ? 'Weniger anzeigen' : 'Alle Pl√§tze anzeigen';
                                collapseBtn.style.display = showAll ? 'inline-block' : 'none';
                            } else {
                                showAllCoursesBtn.style.display = 'none';
                                collapseBtn.style.display = 'none';
                            }
                            
                            // üé≤üìã Hybrid-Sortierung: Random wenn collapsed, alphabetisch wenn expanded
                            const sortedCourses = showAll 
                                ? [...courses].sort((a, b) => a.name.localeCompare(b.name))  // Alphabetisch
                                : [...courses].sort(() => Math.random() - 0.5);              // Random
                            
                            // Zeige nur 3 oder alle
                            const displayCourses = (showAll || sortedCourses.length <= 3) ? sortedCourses : sortedCourses.slice(0, 3);
                            manageList.innerHTML = displayCourses.map(c => `
                  <div class="course-item" onclick="this.classList.toggle('active'); event.stopPropagation();" 
                       style="display:flex;justify-content:space-between;align-items:center;padding:10px;background:var(--color-bg-primary);margin-bottom:8px;border-radius:8px;">
                <div style="flex:1;">
                    <div style="font-weight:600;font-size:14px;line-height:1.4;">${c.name}</div>
                    <div class="course-info" style="font-size:12px;color:var(--color-text-secondary);margin-top:2px;">CR ${c.cr.toFixed(1)} ‚Ä¢ SR ${c.sr} ‚Ä¢ Par ${c.par || (c.holes === 9 ? 36 : 72)}<span class="mobile-bullet"> ‚Ä¢ </span><span class="desktop-break"></span>${c.holes} L√∂cher</div>
                </div>
                    <div class="course-actions" style="flex-direction: column; gap: 6px;">
                      <button onclick="event.stopPropagation(); editCourse('${c.id}')" class="small"
                        style="background:var(--color-border);color:var(--color-text-secondary);font-size:14px;padding:4px 6px;line-height:1;" 
                        title="Bearbeiten">‚úèÔ∏è</button>
                      <button onclick="event.stopPropagation(); deleteCourse('${c.id}')" class="small"
                        style="background:var(--color-border);color:var(--color-text-secondary);font-size:14px;padding:4px 6px;line-height:1;" 
                        title="L√∂schen">üóëÔ∏è</button>
                    </div>
                  </div>
                `).join('');
                        }
                    }
                }
        
                function filterCoursesByHoles() {
                    const selectedHoles = parseInt(document.querySelector('input[name="roundHoles"]:checked').value);
                    const select = document.getElementById('roundCourse');
                    document.getElementById('roundStrokes').value = '';
                    updateStrokesSuffix();
                    
                    const courseCounts = {};
                    const lastPlayedDates = {}; // üîß NEU: Tracke letztes Spieldatum
                    
                    if (myGolfer && myGolfer.rounds) {
                        myGolfer.rounds.forEach(round => {
                            const course = courses.find(c => c.name === round.course && c.holes === round.holes);
                            if (course) {
                                courseCounts[course.id] = (courseCounts[course.id] || 0) + 1;
                                
                                // üîß NEU: Speichere das neueste Datum
                                const roundDate = new Date(round.date);
                                if (!lastPlayedDates[course.id] || roundDate > lastPlayedDates[course.id]) {
                                    lastPlayedDates[course.id] = roundDate;
                                }
                            }
                        });
                    }
                    
                    let html = '<option value="">Platz ausw√§hlen</option>';
                    const filteredCourses = courses.filter(c => c.holes === selectedHoles);
                    
                    if (filteredCourses.length === 0) {
                        html += `<option value="" disabled>Kein ${selectedHoles}-Loch-Platz angelegt</option>`;
                    } else {
                        // üîß 3-Level Sortierung: 1. Play Count, 2. Letztes Datum, 3. Alphabetisch
                        const sortedCourses = [...filteredCourses].sort((a, b) => {
                            // 1. Prim√§r: Play Count (absteigend)
                            const countDiff = (courseCounts[b.id]||0) - (courseCounts[a.id]||0);
                            if (countDiff !== 0) return countDiff;
                            
                            // 2. Sekund√§r: Letztes Datum (neuestes zuerst)
                            const dateA = lastPlayedDates[a.id];
                            const dateB = lastPlayedDates[b.id];
                            if (dateA && dateB) {
                                return dateB - dateA; // Neueres Datum zuerst
                            }
                            if (dateA) return -1; // A gespielt, B nicht
                            if (dateB) return 1;  // B gespielt, A nicht
                            
                            // 3. Terti√§r: Alphabetisch (falls beide nie gespielt)
                            return a.name.localeCompare(b.name);
                        });
                        
                        sortedCourses.forEach(c => {
                            const playCount = courseCounts[c.id] || 0;
                            const countText = playCount > 0 ? ` ‚Ä¢ ${playCount}x` : '';
                            const par = c.par || (c.holes === 9 ? 36 : 72);
                            const courseHcp = calculateCourseHandicap(myGolfer.handicapIndex, c.sr, c.cr, par);
                            html += `<option value="${c.id}">${c.name}${countText}</option>`;
                        });
                    }
                    
                    select.innerHTML = html;
                    select.value = '';
                
                    const roundCourseSelect = document.getElementById('roundCourse');
                    roundCourseSelect.onchange = function () {
                        updateStrokesPlaceholder();
                        autoFocusStrokesField();
                    };
                    updateStrokesPlaceholder();
                }
        
        
        function updateStrokesPlaceholder() {
            const courseId = document.getElementById('roundCourse').value;
            const course = courses.find(c => c.id === courseId);
            const strokesInput = document.getElementById('roundStrokes');
        
            if (course) {
                const is9HoleRound = course.holes === 9;
                const par = course.par;
                const cr = course.cr;
                const sr = course.sr;
        
                let adjustedIndex = myGolfer.handicapIndex;
                if (is9HoleRound) {
                    adjustedIndex /= 2; // Halbes Index f√ºr 9-Loch
                }
        
                const courseHcp = calculateCourseHandicap(adjustedIndex, sr, cr, par);
                const vorgabeText = courseHcp >= 0 ? `+${courseHcp}` : courseHcp;
                strokesInput.placeholder = `Par ${par} ‚Ä¢ Vorgabe ${vorgabeText}`;
            } else {
                strokesInput.placeholder = 'Schl√§ge eingeben';
            }
        }
        
        function updateStrokesSuffix() {
            const strokesInput = document.getElementById('roundStrokes');
            const suffix = document.getElementById('strokesSuffix');
            
            if (strokesInput.value && parseInt(strokesInput.value) > 0) {
                suffix.textContent = strokesInput.value + ' Schl√§ge';
                suffix.style.display = 'block';
                strokesInput.style.color = 'transparent';
            } else {
                suffix.style.display = 'none';
                strokesInput.style.color = '';
            }
        }
        
        document.getElementById('roundStrokes').addEventListener('input', updateStrokesSuffix);
        
        
                function validateRoundData(strokes, holes, date) {
                    const errors = [];
                    
                    const minStrokes = holes === 9 ? 25 : 50;
                    const maxStrokes = holes === 9 ? 80 : 160;
                    
                    if (!strokes || strokes < minStrokes || strokes > maxStrokes) {
                        errors.push(`Schl√§ge m√ºssen zwischen ${minStrokes} und ${maxStrokes} liegen`);
                    }
                    
                    if (!date || new Date(date) > new Date()) {
                        errors.push('Datum darf nicht in der Zukunft liegen');
                    }
                    
                    // Pr√ºfe ob Datum zu weit in der Vergangenheit (z.B. √§lter als 3 Jahre)
                    const threeYearsAgo = new Date();
                    threeYearsAgo.setFullYear(threeYearsAgo.getFullYear() - 3);
                    if (date && new Date(date) < threeYearsAgo) {
                        errors.push('Datum liegt mehr als 3 Jahre zur√ºck - bitte pr√ºfen');
                    }
                    
                    return errors;
                }
        
                function saveRound() {
            const courseId = document.getElementById('roundCourse').value;
            const course = courses.find(c => c.id === courseId);
            if (!course) {
                return alert('Bitte zuerst einen Platz anlegen oder ausw√§hlen!');
            }
        
            const strokes = parseInt(document.getElementById('roundStrokes').value);
            const holes = parseInt(document.querySelector('input[name="roundHoles"]:checked').value);
            const date = document.getElementById('roundDate').value;
        
            const validationErrors = validateRoundData(strokes, holes, date);
            if (validationErrors.length > 0) {
                return alert('‚ùå Eingabefehler:\n\n' + validationErrors.join('\n'));
            }
        
        // WHS Score Differential Berechnung (gleich f√ºr 9 und 18 Loch)
        const cr = course.cr;
        const sr = course.sr;
        const scoreDifferential = ((strokes - cr) * (113 / sr)).toFixed(1);
        
        
            const isOfficial = document.getElementById('roundOfficial').checked;
        
            const courseHandicap = getPlayingCourseHandicap(
                { holes: holes }, course, myGolfer.handicapIndex
            );
        
            // WHS 2024: F√ºr 9-Loch-Runden SD in 18-Loch-√Ñquivalent umrechnen
        const rawSD = parseFloat(scoreDifferential);
        const isNineHole = holes === 9;
        const effectiveSD = isNineHole
            ? convert9HoleTo18HoleSD(rawSD, myGolfer.handicapIndex)
            : rawSD;

        const round = {
            id: generateUniqueId(),
            date: date,
            course: course.name,
            holes: holes,
            strokes: strokes,
            cr: cr.toFixed(1),
            sr: sr.toFixed(0),
            scoreDifferential: effectiveSD,
            scoreDifferential9: isNineHole ? rawSD : null, // Rohwert f√ºr Anzeige
            playingHcp: myGolfer.handicapIndex,
            courseHandicap: courseHandicap,
            official: isOfficial
        };
        
            myGolfer.rounds.push(round);
        
            // Pr√ºfe ob historische Runde
            const existingDates = myGolfer.rounds.slice(0, -1).map(r => new Date(r.date));
            const isHistorical = existingDates.length > 0 &&
                new Date(date) < new Date(Math.max(...existingDates));
        
            if (isHistorical) {
                recalculateHistory();
            } else {
                updateMyHandicap();

                // WHS: Exceptional Score Reduction (ESR) ‚Äî VOR unofficial HCP
                const esrHcp = round.playingHcp;
                const esrDiff = esrHcp - round.scoreDifferential;
                if (isOfficial && esrDiff >= 10.0) {
                    myGolfer.handicapIndex = Math.max(-5.0, myGolfer.handicapIndex - 2.0);
                    if (myGolfer.hcpHistory) {
                        const lastEntry = myGolfer.hcpHistory[myGolfer.hcpHistory.length - 1];
                        if (lastEntry) lastEntry.hcp = myGolfer.handicapIndex;
                    }
                    alert('üèÜ Exceptional Score! Dein Handicap wurde zus√§tzlich um -2.0 reduziert!');
                } else if (isOfficial && esrDiff >= 7.0) {
                    myGolfer.handicapIndex = Math.max(-5.0, myGolfer.handicapIndex - 1.0);
                    if (myGolfer.hcpHistory) {
                        const lastEntry = myGolfer.hcpHistory[myGolfer.hcpHistory.length - 1];
                        if (lastEntry) lastEntry.hcp = myGolfer.handicapIndex;
                    }
                    alert('üèÜ Exceptional Score! Dein Handicap wurde zus√§tzlich um -1.0 reduziert!');
                }

                // Allzeit-Tiefstwert nach ESR pr√ºfen
                if (myGolfer.lowestHandicapIndex === undefined || myGolfer.handicapIndex < myGolfer.lowestHandicapIndex) {
                    myGolfer.lowestHandicapIndex = myGolfer.handicapIndex;
                }

                updateUnofficialHandicap();
            }
        

        localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
        
            if (myGolfer.rounds.length % 5 === 0) {
                setTimeout(() => {
                    if (confirm(`Du hast ${myGolfer.rounds.length} Runden erfasst! Automatisches Backup jetzt erstellen?`)) {
                        exportData();
                    }
                }, 500);
            }
        
            updateUI();
            document.getElementById('roundStrokes').value = '';
            document.getElementById('roundOfficial').checked = false;
            updateStrokesSuffix();
            
            const sdInfo = round.scoreDifferential9 !== null
                ? `${round.scoreDifferential9} (‚Üí 18L: ${round.scoreDifferential})`
                : `${round.scoreDifferential}`;
            alert(`Runde gespeichert!\nDifferential: ${sdInfo}\n${isOfficial ? 'Offizielles' : 'Inoffizielles'} HCP: ${myGolfer[isOfficial ? 'handicapIndex' : 'unofficialHandicap'].toFixed(1)}`);
            
            // Scroll to top to see updated dashboard
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
                
        function updateMyHandicap() {
    const officialRounds = myGolfer.rounds
        .filter(r => r.official !== false)
        .slice(-20)
        .map(r => ({ id: r.id, sd: r.scoreDifferential }))
        .sort((a, b) => a.sd - b.sd);

    if (officialRounds.length === 0) {
        myGolfer.handicapIndex = myGolfer.startHcp;
        return;
    }

    const count = officialRounds.length;

    if (count < 3) {
        myGolfer.handicapIndex = myGolfer.startHcp;
        myGolfer.countedRoundIds = [];
        return;
    }

    const { numCounted, adjustment } = getWHSParameters(count);
    const bestRounds = officialRounds.slice(0, numCounted);
    let newHcp = bestRounds.reduce((a, b) => a + b.sd, 0) / numCounted;

    // 12-Monats-Fenster f√ºr Soft/Hard Cap
    const hcpHistory = myGolfer.hcpHistory || [];
    const now = new Date().toISOString();
    const lowestHcp12m = getLowestHcpLast12Months(now, hcpHistory, myGolfer.startHcp);

    // WHS-Reihenfolge: Adjustment ‚Üí Runden ‚Üí Soft Cap ‚Üí Hard Cap
    newHcp += adjustment;
    newHcp = Math.round(newHcp * 10) / 10;
    newHcp = applyCaps(newHcp, lowestHcp12m);

    myGolfer.handicapIndex = newHcp;

    // Allzeit-Tiefstwert pflegen
    if (myGolfer.lowestHandicapIndex === undefined || newHcp < myGolfer.lowestHandicapIndex) {
        myGolfer.lowestHandicapIndex = newHcp;
    }

    // HCP-History aktualisieren
    const lastRoundDate = myGolfer.rounds
        .filter(r => r.official !== false)
        .slice(-1)[0]?.date || now;
    
    if (!myGolfer.hcpHistory) myGolfer.hcpHistory = [];
    myGolfer.hcpHistory.push({ date: lastRoundDate, hcp: newHcp });

    // hcpHistory begrenzen: max. 100 Eintr√§ge (12-Monats-Fenster braucht ~50 max)
    if (myGolfer.hcpHistory.length > 100) {
        myGolfer.hcpHistory = myGolfer.hcpHistory.slice(-100);
    }

    // Counted Round IDs (jetzt einfach, keine kombinierten Runden mehr)
    myGolfer.countedRoundIds = bestRounds.map(r => r.id);
}
            
         function updateUnofficialHandicap() {
            const allRounds = myGolfer.rounds
                .slice(-20)
                .map(r => ({ id: r.id, sd: r.scoreDifferential }))
                .sort((a, b) => a.sd - b.sd);
        
            if (allRounds.length === 0) {
                myGolfer.unofficialHandicap = myGolfer.startHcp;
                return;
            }
        
            const count = allRounds.length;
        
            if (count < 3) {
                myGolfer.unofficialHandicap = myGolfer.startHcp;
                return;
            }
        
            const { numCounted, adjustment } = getWHSParameters(count);
            const bestRounds = allRounds.slice(0, numCounted);
            let newHcp = bestRounds.reduce((a, b) => a + b.sd, 0) / numCounted;
        
            // ‚úÖ FIX 1+3: 12-Monats-Fenster, nur offizielle HCP-History
            const hcpHistory = myGolfer.hcpHistory || [];
            const now = new Date().toISOString();
            const lowestHcp12m = getLowestHcpLast12Months(now, hcpHistory, myGolfer.startHcp);
        
            // WHS-Reihenfolge: Adjustment ‚Üí Runden ‚Üí Soft Cap ‚Üí Hard Cap
            newHcp += adjustment;
            newHcp = Math.round(newHcp * 10) / 10;
            newHcp = applyCaps(newHcp, lowestHcp12m);

            myGolfer.unofficialHandicap = newHcp;
        
        }
                
                function getWHSParameters(count) {
                    let numCounted = 1;
                    let adjustment = 0;
            
                    if (count >= 3 && count <= 4) {
                       numCounted = 1;
                       adjustment = count === 3 ? -2.0 : -1.0;
                  } else if (count === 5) {
                      numCounted = 1;
                      adjustment = 0;
                  } else if (count === 6) {
                      numCounted = 2;
                      adjustment = -1.0;
                  } else if (count >= 7 && count <= 8) {
                      numCounted = 2;
                      adjustment = 0;
                   } else if (count >= 9 && count <= 11) {
                      numCounted = 3;
                      adjustment = 0;
                  } else if (count >= 12 && count <= 14) {
                      numCounted = 4;
                      adjustment = 0;
                   } else if (count >= 15 && count <= 16) {
                       numCounted = 5;
                      adjustment = 0;
                   } else if (count >= 17 && count <= 18) {
                       numCounted = 6;
                       adjustment = 0;
                    } else if (count === 19) {
                        numCounted = 7;
                        adjustment = 0;
                    } else if (count >= 20) {
                        numCounted = 8;
                        adjustment = 0;
                    }
                    
        return { numCounted, adjustment };
        }

        // WHS: Niedrigsten Handicap Index der letzten 12 Monate berechnen
        // Wird f√ºr Soft/Hard Cap ben√∂tigt (statt allzeit-Tiefstwert)
        function getLowestHcpLast12Months(asOfDate, hcpHistory, fallback) {
            if (!hcpHistory || hcpHistory.length === 0) return fallback;
            
            const cutoff = new Date(asOfDate);
            cutoff.setMonth(cutoff.getMonth() - 12);
            
            const inWindow = hcpHistory.filter(h => {
                const d = new Date(h.date);
                return d >= cutoff && d <= new Date(asOfDate);
            });
            
            if (inWindow.length === 0) return fallback;
            return Math.min(...inWindow.map(h => h.hcp));
        }

// WHS: Soft Cap + Hard Cap anwenden
// Soft Cap: 50% der √úberschreitung √ºber Low HI(12m) + 3.0
// Hard Cap: Maximum Low HI(12m) + 5.0
function applyCaps(hcp, lowestHcp12m) {
    const softCapThreshold = lowestHcp12m + 3.0;
    const hardCapLimit = lowestHcp12m + 5.0;
    if (hcp > softCapThreshold) {
        // 50% der √úberschreitung √ºber Soft Cap Schwelle
        hcp = softCapThreshold + (hcp - softCapThreshold) * 0.5;
        hcp = Math.round(hcp * 10) / 10;
    }
    // Hard Cap: absolutes Maximum
    hcp = Math.min(hcp, hardCapLimit);
    // WHS-Grenzen: -5.0 bis 54.0
    hcp = Math.max(-5.0, Math.min(54.0, hcp));
    return hcp;
}

// WHS 2024: Expected Score ‚Äì erwartetes 9-Loch Score Differential
// Basiert auf dem USGA-Modell. Die exakte Formel ist propriet√§r,
// aber diese N√§herung passt zum offiziellen USGA-Beispiel:
// HI 14.0 ‚Üí erwartetes 9h-SD = 8.5 ‚Üí best√§tigt: HI/2 + 1.5
function getExpected9HoleSD(handicapIndex) {
    return (handicapIndex / 2) + 1.5;
}

// WHS 2024: 9-Loch SD in 18-Loch-√Ñquivalent umrechnen
// 18h-SD = tats√§chliches 9h-SD + erwartetes 9h-SD
function convert9HoleTo18HoleSD(sd9, handicapIndex) {
    return parseFloat((sd9 + getExpected9HoleSD(handicapIndex)).toFixed(1));
}
        
        function toggleAdvancedStats() {
            const stats = document.getElementById('advancedStats');
            const btn = document.querySelector('.toggle-stats-btn');
            const isVisible = stats.classList.contains('active');
        
            if (!isVisible) {
                renderAdvancedStats();
                // Render chart when opening stats
                const rounds = myGolfer.rounds || [];
                if (rounds.length >= 2) {
                    const chartWrapper = document.getElementById('handicapChartWrapper');
                    chartWrapper.style.display = 'block';
                    setTimeout(() => renderChart(), 50);
                }
            }
        
            stats.classList.toggle('active');
            btn.textContent = isVisible ? 'üìä Erweiterte Statistiken' : 'Statistiken ausblenden';

            // Scroll behavior
            if (!isVisible) {
                // Opening: scroll to top of stats (nach CSS-Transition)
                setTimeout(() => {
                    stats.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 400);
            } else {
                // Closing: scroll to top of page
                setTimeout(() => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 100);
            }
        
            if (window.matchMedia("(hover: none)").matches) {
                btn.blur();
                document.body.focus();
                requestAnimationFrame(() => {
                    btn.style.pointerEvents = 'none';
                    setTimeout(() => {
                        btn.style.pointerEvents = '';
                    }, 50);
                });
            }
        }
        
        function renderAdvancedStats() {
            const rounds = myGolfer.rounds;
            if (rounds.length === 0) return;
        
            const generalStats = document.getElementById('generalStats');
            const courseStats = document.getElementById('courseStats');
            const trendStats = document.getElementById('trendStats');
            const nextGoalEl = document.getElementById('nextGoal');
        
            const rounds18 = rounds.filter(r => r.holes === 18);
            const rounds9 = rounds.filter(r => r.holes === 9);
            const last10 = rounds.slice(-10);
            const last5 = rounds.slice(-5);

            // Letzte 20 Runden: Basis f√ºr SD-basierte Statistiken
            // Vermeidet Verzerrung durch alte Runden mit stark abweichendem HCP
            const recent20 = rounds.slice(-20);
        
            // =========================================================
            // VORAB-BERECHNUNGEN (ben√∂tigt f√ºr Ziele UND sp√§tere Stats)
            // =========================================================
        
            // --- Allgemeine SD-Werte (letzte 20) ---
            const sdValues = recent20.map(r => r.scoreDifferential);
            const bestSD = Math.min(...sdValues).toFixed(1);
            const worstSD = Math.max(...sdValues).toFixed(1);
            const avgSD = (sdValues.reduce((a, b) => a + b, 0) / sdValues.length).toFixed(1);
        
            // --- Konstanz (letzte 20) ---
            const variance = sdValues.reduce((sum, sd) => sum + Math.pow(sd - parseFloat(avgSD), 2), 0) / sdValues.length;
            const consistency = Math.sqrt(variance).toFixed(1);
        
            // --- Unter HCP / Serien (letzte 20) ---
            const underPar = recent20.filter(r => r.scoreDifferential <= r.playingHcp).length;
            let currentStreak = 0;
            let bestStreak = 0;
            let currentStreakActive = false;
            recent20.forEach((r, i) => {
                if (r.scoreDifferential <= r.playingHcp) {
                    currentStreak++;
                    if (i === recent20.length - 1) currentStreakActive = true;
                } else {
                    bestStreak = Math.max(bestStreak, currentStreak);
                    currentStreak = 0;
                    currentStreakActive = false;
                }
            });
            bestStreak = Math.max(bestStreak, currentStreak);
            const seriesText = bestStreak > 0
                ? `${bestStreak} Runden${currentStreakActive && currentStreak > 0 ? ` (aktuell: ${currentStreak})` : ''}`
                : 'Noch keine';
        
            // --- Offizielle / Inoffizielle Runden (letzte 20) ---
            const officialRounds = recent20.filter(r => r.official !== false);
            const unofficialRounds = recent20.filter(r => r.official === false);
            const avgSDOfficial = officialRounds.length > 0
                ? (officialRounds.map(r => r.scoreDifferential).reduce((a, b) => a + b, 0) / officialRounds.length).toFixed(1)
                : '-';
            const avgSDUnofficial = unofficialRounds.length > 0
                ? (unofficialRounds.map(r => r.scoreDifferential).reduce((a, b) => a + b, 0) / unofficialRounds.length).toFixed(1)
                : '-';
        
            // --- Performance unter Druck (letzte 20) ---
            let pressureText = 'Nur offizielle Runden';
            let pressureColor = 'var(--color-text-secondary)';
            if (unofficialRounds.length > 0 && officialRounds.length > 0) {
                const pressureDiff = (parseFloat(avgSDOfficial) - parseFloat(avgSDUnofficial)).toFixed(1);
                if (parseFloat(pressureDiff) > 0.5) {
                    pressureText = `+${pressureDiff} SD schlechter unter Druck`;
                    pressureColor = 'var(--color-danger)';
                } else if (parseFloat(pressureDiff) < -0.5) {
                    pressureText = `${pressureDiff} SD besser unter Druck üí™`;
                    pressureColor = 'var(--color-primary)';
                } else {
                    pressureText = 'Konstant (¬±0,5 SD)';
                    pressureColor = 'var(--color-text-secondary)';
                }
            }

            // Alle offiziellen/inoffiziellen Runden (f√ºr Z√§hler und Ziele)
            const allOfficialRounds = rounds.filter(r => r.official !== false);
            const allUnofficialRounds = rounds.filter(r => r.official === false);

            // --- Beste/Schlechteste Runde (konkret, letzte 20) ---
            const bestRound = recent20.reduce((best, r) => r.scoreDifferential < best.scoreDifferential ? r : best, recent20[0]);
            const worstRound = recent20.reduce((worst, r) => r.scoreDifferential > worst.scoreDifferential ? r : worst, recent20[0]);
            
            function formatRoundInfo(r) {
                const c = courses.find(c => c.name === r.course && c.holes === r.holes);
                const par = c ? c.par : (r.holes === 9 ? 36 : 72);
                const toPar = r.strokes - par;
                const toParText = toPar > 0 ? `+${toPar}` : `${toPar}`;
                const name = r.course;
                return `${r.strokes} (${toParText}) ‚Ä¢ ${r.date}<br>${name}`;
            }
            const bestRoundText = formatRoundInfo(bestRound);
            const worstRoundText = formatRoundInfo(worstRound);

            // --- Scoring Average ---
            const rounds18recent = recent20.filter(r => r.holes === 18);
            const rounds9recent = recent20.filter(r => r.holes === 9);
            const avgStrokes18 = rounds18recent.length > 0 
                ? (rounds18recent.reduce((s, r) => s + r.strokes, 0) / rounds18recent.length).toFixed(0) : '-';
            const avgStrokes9 = rounds9recent.length > 0 
                ? (rounds9recent.reduce((s, r) => s + r.strokes, 0) / rounds9recent.length).toFixed(0) : '-';
            let scoringAvgText = '';
            if (avgStrokes18 !== '-' && avgStrokes9 !== '-') {
                scoringAvgText = `${avgStrokes18} (18L) / ${avgStrokes9} (9L)`;
            } else if (avgStrokes18 !== '-') {
                scoringAvgText = `${avgStrokes18} (18L)`;
            } else if (avgStrokes9 !== '-') {
                scoringAvgText = `${avgStrokes9} (9L)`;
            } else {
                scoringAvgText = '-';
            }

            // --- Konstanz: Brutto zu Par + Netto Schwankungsbreite ---
            let consistencyText = `œÉ ${consistency}`;
            if (recent20.length >= 2) {
                // Brutto zu Par (normalisiert auf 18L)
                const bruttoToPar = recent20.map(r => {
                    const c = courses.find(c => c.name === r.course && c.holes === r.holes);
                    const par = c ? c.par : (r.holes === 9 ? 36 : 72);
                    const tp = r.strokes - par;
                    return r.holes === 9 ? tp * 2 : tp;
                }).sort((a, b) => a - b);
                const bp10 = Math.floor(bruttoToPar.length * 0.1);
                const bp90 = Math.min(Math.ceil(bruttoToPar.length * 0.9) - 1, bruttoToPar.length - 1);
                const bLow = Math.round(bruttoToPar[bp10]);
                const bHigh = Math.round(bruttoToPar[bp90]);
                const bLowText = bLow > 0 ? `+${bLow}` : bLow === 0 ? 'Par' : `${bLow}`;
                const bHighText = bHigh > 0 ? `+${bHigh}` : bHigh === 0 ? 'Par' : `${bHigh}`;

                // Netto (normalisiert auf 18L)
                const nettoVals = recent20.map(r => {
                    const c = courses.find(c => c.name === r.course && c.holes === r.holes);
                    const par = c ? c.par : (r.holes === 9 ? 36 : 72);
                    const netto = r.strokes - (par + (r.courseHandicap || 0));
                    return r.holes === 9 ? netto * 2 : netto;
                }).sort((a, b) => a - b);
                const np10 = Math.floor(nettoVals.length * 0.1);
                const np90 = Math.min(Math.ceil(nettoVals.length * 0.9) - 1, nettoVals.length - 1);
                const nLow = Math.round(nettoVals[np10]);
                const nHigh = Math.round(nettoVals[np90]);
                const nLowText = nLow > 0 ? `+${nLow}` : nLow === 0 ? '¬±0' : `${nLow}`;
                const nHighText = nHigh > 0 ? `+${nHigh}` : nHigh === 0 ? '¬±0' : `${nHigh}`;

                consistencyText = `${bLowText} bis ${bHighText} zu Par<br>Netto ${nLowText} bis ${nHighText}`;
            }

            // --- N√§chste HCP-Verbesserung: bei welchem SD? ---
            let nextImprovementText = '-';
            if (allOfficialRounds.length >= 3) {
                const officialSDs = allOfficialRounds.slice(-20)
                    .map(r => r.scoreDifferential)
                    .sort((a, b) => a - b);
                const { numCounted } = getWHSParameters(Math.min(officialSDs.length, 20));
                if (officialSDs.length >= numCounted) {
                    // Die h√∂chste SD die aktuell in den besten N gez√§hlt wird
                    const threshold = officialSDs[numCounted - 1];
                    nextImprovementText = `SD ‚â§ ${threshold.toFixed(1)}`;
                }
            }

            // --- Runden seit letzter HCP-√Ñnderung ---
            let roundsSinceChange = '-';
            if (myGolfer.hcpHistory && myGolfer.hcpHistory.length >= 2) {
                const lastHcp = myGolfer.hcpHistory[myGolfer.hcpHistory.length - 1].hcp;
                let changeIdx = myGolfer.hcpHistory.length - 1;
                for (let i = myGolfer.hcpHistory.length - 2; i >= 0; i--) {
                    if (Math.abs(myGolfer.hcpHistory[i].hcp - lastHcp) > 0.05) {
                        break;
                    }
                    changeIdx = i;
                }
                const roundsAfter = allOfficialRounds.filter(r => 
                    new Date(r.date) >= new Date(myGolfer.hcpHistory[changeIdx].date)
                ).length;
                roundsSinceChange = roundsAfter <= 1 ? 'Gerade ge√§ndert' : `${roundsAfter} Runden`;
            }
        
            // --- Trend-Werte ---
            const hcpStart = myGolfer.startHcp;
            const hcpCurrent = myGolfer.handicapIndex;
            const hcpChange = (hcpCurrent - hcpStart).toFixed(1);
            const hcpChangePercent = hcpStart !== 0 ? ((hcpChange / hcpStart) * 100).toFixed(1) : '0.0';
            const trendEmoji = hcpChange < 0 ? 'üìà' : (hcpChange > 0 ? 'üìâ' : '‚û°Ô∏è');
            const trendText = hcpChange < 0 ? 'Verbesserung' : (hcpChange > 0 ? 'Verschlechterung' : 'Stabil');
        
            // --- HCP vor 30 Tagen ---
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            const rounds30DaysAgo = myGolfer.rounds.filter(r => new Date(r.date) <= thirtyDaysAgo);
            let hcp30DaysAgo = myGolfer.startHcp;
            if (rounds30DaysAgo.length >= 3) {
                const officialRounds30 = rounds30DaysAgo
                    .filter(r => r.official !== false)
                    .slice(-20)
                    .map(r => ({ id: r.id, sd: r.scoreDifferential }))
                    .sort((a, b) => a.sd - b.sd);
                if (officialRounds30.length >= 3) {
                    const { numCounted, adjustment } = getWHSParameters(officialRounds30.length);
                    const bestRounds30 = officialRounds30.slice(0, numCounted);
                    let avgHcp = bestRounds30.reduce((a, b) => a + b.sd, 0) / numCounted;
                    const lowestHcp = getLowestHcpLast12Months(
                            thirtyDaysAgo.toISOString(),
                            myGolfer.hcpHistory || [],
                            myGolfer.startHcp
                        );
                    // WHS-Reihenfolge: Adjustment ‚Üí Caps
                    avgHcp += adjustment;
                    avgHcp = Math.round(avgHcp * 10) / 10;
                    avgHcp = applyCaps(avgHcp, lowestHcp);
                    hcp30DaysAgo = avgHcp;
                }
            }
            const monthChange = (myGolfer.handicapIndex - hcp30DaysAgo).toFixed(1);
            const monthEmoji = monthChange < 0 ? 'üìà' : (monthChange > 0 ? 'üìâ' : '‚û°Ô∏è');
            const monthText = monthChange < 0 ? 'Verbesserung' : (monthChange > 0 ? 'Verschlechterung' : 'Stabil');
        
            // --- Verbesserungsrate ---
            let improvementText = '-';
            let improvementColor = 'var(--color-text-secondary)';
            if (rounds.length >= 2) {
                const firstRound = rounds[0];
                const lastRound = rounds[rounds.length - 1];
                const monthsDiff = (new Date(lastRound.date) - new Date(firstRound.date)) / (1000 * 60 * 60 * 24 * 30.44);
                if (monthsDiff >= 1) {
                    const improvementRate = ((hcpCurrent - hcpStart) / monthsDiff).toFixed(2);
                    if (parseFloat(improvementRate) < -0.1) {
                        improvementText = `${improvementRate} HCP/Monat üìà`;
                        improvementColor = 'var(--color-primary)';
                    } else if (parseFloat(improvementRate) > 0.1) {
                        improvementText = `+${improvementRate} HCP/Monat üìâ`;
                        improvementColor = 'var(--color-danger)';
                    } else {
                        improvementText = 'Stabil (¬±0,1 HCP/Monat)';
                    }
                }
            }
        
            // --- Form-Momentum ---
            let momentumText = '-';
            let momentumColor = 'var(--color-text-secondary)';
            if (rounds.length >= 15) {
                const previous10 = rounds.slice(-15, -5);
                if (last5.length >= 5 && previous10.length >= 5) {
                    const avgLast5SD = last5.map(r => r.scoreDifferential).reduce((a, b) => a + b, 0) / 5;
                    const avgPrev10SD = previous10.map(r => r.scoreDifferential).reduce((a, b) => a + b, 0) / previous10.length;
                    const momentum = avgLast5SD - avgPrev10SD;
                    if (momentum <= -1.0) {
                        momentumText = `üìà Aufw√§rtstrend (${momentum.toFixed(1)} SD)`;
                        momentumColor = 'var(--color-primary)';
                    } else if (momentum >= 1.0) {
                        momentumText = `üìâ Abw√§rtstrend (+${momentum.toFixed(1)} SD)`;
                        momentumColor = 'var(--color-danger)';
                    } else {
                        momentumText = '‚û°Ô∏è Stabil';
                        momentumColor = 'var(--color-text-secondary)';
                    }
                }
            }
        
            // --- Saisonale Performance (letzte 20) ---
            const monthlyStats = {};
            const monthNames = ['Jan', 'Feb', 'M√§r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
            recent20.forEach(r => {
                const month = new Date(r.date).getMonth();
                if (!monthlyStats[month]) {
                    monthlyStats[month] = { scoreDiffs: [], count: 0 };
                }
                monthlyStats[month].scoreDiffs.push(r.scoreDifferential);
                monthlyStats[month].count++;
            });
            let bestMonth = null;
            let worstMonth = null;
            let bestAvg = Infinity;
            let worstAvg = -Infinity;
            Object.entries(monthlyStats).forEach(([month, data]) => {
                if (data.count >= 2) {
                    const avg = data.scoreDiffs.reduce((a, b) => a + b, 0) / data.count;
                    if (avg < bestAvg) { bestAvg = avg; bestMonth = month; }
                    if (avg > worstAvg) { worstAvg = avg; worstMonth = month; }
                }
            });
            const bestMonthText = bestMonth !== null ? `${monthNames[bestMonth]} (√ò SD ${bestAvg.toFixed(1)})` : 'Zu wenig Daten';
            const worstMonthText = worstMonth !== null ? `${monthNames[worstMonth]} (√ò SD ${worstAvg.toFixed(1)})` : 'Zu wenig Daten';
        
            // --- √ò SD letzte 10 ---
            const avgSDLast10 = last10.length > 0
                ? (last10.map(r => r.scoreDifferential).reduce((a, b) => a + b, 0) / last10.length).toFixed(1)
                : '-';
            const sdLast10Diff = parseFloat(avgSDLast10) - parseFloat(avgSD);
            const sdLast10Color = sdLast10Diff < -0.5 ? 'var(--color-primary)' : sdLast10Diff > 0.5 ? 'var(--color-danger)' : 'var(--color-text-secondary)';
        
            // =========================================================
            // N√ÑCHSTES ZIEL (jetzt sind alle Variablen verf√ºgbar)
            // =========================================================
        
            let goalText = 'Weiter so! üí™';
            let goalPriority = 0;
        
            if (allOfficialRounds.length < 20) {
                const remaining = 20 - allOfficialRounds.length;
                goalText = `Noch ${remaining} offizielle Runde${remaining > 1 ? 'n' : ''} bis stabiles HCP (20 Runden)`;
                goalPriority = 100;
            }
        
            if (goalPriority < 95 && myGolfer.handicapIndex > 9.5 && myGolfer.handicapIndex < 54) {
                const toSingle = (myGolfer.handicapIndex - 9.4).toFixed(1);
                goalText = `Noch ${toSingle} Schl√§ge bis Single-Handicap! üèåÔ∏è`;
                goalPriority = 95;
            }
        
            if (goalPriority < 94 && myGolfer.handicapIndex <= 9.5 && myGolfer.handicapIndex > 0) {
                const toPlus = myGolfer.handicapIndex.toFixed(1);
                goalText = `Single-Handicap erreicht! Noch ${toPlus} bis Plus-Handicap üî•`;
                goalPriority = 94;
            }
        
            if (goalPriority < 90 && hcpCurrent < hcpStart && rounds.length >= 5) {
                goalText = `üìâ‚û°Ô∏èüìà Von ${hcpStart.toFixed(1)} auf ${hcpCurrent.toFixed(1)} ‚Äì du hast dein Start-HCP unterboten! Weiter runter!`;
                goalPriority = 90;
            }
        
            if (goalPriority < 85 && hcpStart > 10) {
                const halfTarget = hcpStart / 2;
                const toHalf = (hcpCurrent - halfTarget).toFixed(1);
                if (parseFloat(toHalf) > 0 && parseFloat(toHalf) <= 10) {
                    goalText = `üéä Von ${hcpStart.toFixed(1)} auf ${hcpCurrent.toFixed(1)} ‚Äì Noch ${toHalf} Schl√§ge bis zur Halbierung deines Start-HCP!`;
                    goalPriority = 85;
                }
            }
        
            if (goalPriority < 80 && currentStreakActive && currentStreak >= 2) {
                const nextTarget = currentStreak >= 5 ? 10 : 5;
                goalText = `üî• Aktuelle Serie: ${currentStreak} Runden unter HCP ‚Äì Ziel: ${nextTarget}er-Serie!`;
                goalPriority = 80;
            }
        
            if (goalPriority < 75 && rounds.length >= 2) {
                const firstRound = rounds[0];
                const lastRound = rounds[rounds.length - 1];
                const monthsDiff = (new Date(lastRound.date) - new Date(firstRound.date)) / (1000 * 60 * 60 * 24 * 30.44);
                if (monthsDiff >= 1) {
                    const improvementRateGoal = ((hcpCurrent - hcpStart) / monthsDiff);
                    if (improvementRateGoal < -0.4) {
                        goalText = `üöÄ ${improvementRateGoal.toFixed(1)} HCP in ${Math.round(monthsDiff)} Monaten ‚Äì Auf Rekordjagd! Weiter so!`;
                        goalPriority = 75;
                    }
                }
            }
        
            if (goalPriority < 70) {
                const milestones = [25, 50, 75, 100, 150, 200, 250, 300];
                for (let milestone of milestones) {
                    if (rounds.length < milestone && rounds.length >= milestone - 5) {
                        const remaining = milestone - rounds.length;
                        goalText = `üéâ Noch ${remaining} Runde${remaining > 1 ? 'n' : ''} bis zur magischen ${milestone}! Keep going!`;
                        goalPriority = 70;
                        break;
                    }
                }
            }
        
            if (goalPriority < 65 && last5.length > 0) {
                const recentBestSD = Math.min(...last5.map(r => r.scoreDifferential));
                const allTimeBestSD = parseFloat(bestSD);
                const gapToBest = recentBestSD - allTimeBestSD;
                if (gapToBest > 0 && gapToBest <= 1.0) {
                    goalText = `‚≠ê Beste Runde: SD ${allTimeBestSD} ‚Äì Noch ${gapToBest.toFixed(1)} Schl√§ge bis neuer Rekord!`;
                    goalPriority = 65;
                }
            }
        
            if (goalPriority < 60) {
                const roundTargets = [0, 5, 10, 15, 18, 20, 25, 30, 36, 40, 45, 50, 54];
                for (let target of roundTargets) {
                    const diff = Math.abs(hcpCurrent - target);
                    if (diff > 0 && diff <= 0.3) {
                        goalText = `üéØ HCP ${hcpCurrent.toFixed(1)} ‚Äì Nur noch ${diff.toFixed(1)} bis zur runden ${target.toFixed(1)}!`;
                        goalPriority = 60;
                        break;
                    }
                }
            }
        
            if (goalPriority < 55) {
                const currentMonth = new Date().getMonth();
                const currentYear = new Date().getFullYear();
                const thisMonthOfficial = allOfficialRounds.filter(r => {
                    const rDate = new Date(r.date);
                    return rDate.getMonth() === currentMonth && rDate.getFullYear() === currentYear;
                }).length;
                if (allOfficialRounds.length >= 3) {
                    const firstOfficial = allOfficialRounds[0];
                    const lastOfficial = allOfficialRounds[allOfficialRounds.length - 1];
                    const monthsActive = (new Date(lastOfficial.date) - new Date(firstOfficial.date)) / (1000 * 60 * 60 * 24 * 30.44);
                    if (monthsActive >= 1) {
                        const avgPerMonth = Math.round(allOfficialRounds.length / monthsActive);
                        const target = Math.max(3, avgPerMonth);
                        if (thisMonthOfficial < target) {
                            const remaining = target - thisMonthOfficial;
                            goalText = `üìÖ Diesen Monat: ${thisMonthOfficial}/${target} offizielle Runden ‚Äì noch ${remaining} f√ºr dein HCP-Monatsziel!`;
                            goalPriority = 55;
                        }
                    }
                }
            }
        
            if (goalPriority < 50 && allUnofficialRounds.length > 0 && allOfficialRounds.length > 0) {
                const pressureDiffGoal = parseFloat(avgSDOfficial) - parseFloat(avgSDUnofficial);
                if (pressureDiffGoal > 0.5) {
                    goalText = `üèÜ Performance unter Druck: +${pressureDiffGoal.toFixed(1)} SD ‚Äì Ziel: Auf ¬±0,5 verbessern!`;
                    goalPriority = 50;
                }
            }
        
            if (goalPriority < 45) {
                const consistencyVal = parseFloat(consistency);
                if (consistencyVal >= 2.5 && consistencyVal <= 3.5) {
                    goalText = `üéØ SD-Streuung: ${consistency} ‚Äì Ziel: Unter 2,5 f√ºr Elite-Konstanz!`;
                    goalPriority = 45;
                }
            }
        
            if (goalPriority < 40 && last5.length >= 5) {
                // Klassisches Netto f√ºr die letzten 5 Runden:
                const nettoLast5 = last5.map(r => {
                    const course = courses.find(c => c.name === r.course && c.holes === r.holes);
                    const par = course ? course.par : (r.holes === 9 ? 36 : 72);
                    const allowedStrokes = par + r.courseHandicap;
                    const netto = r.strokes - allowedStrokes;
                    
                    // ‚úÖ Normalisiere 9-Loch auf 18-Loch
                    return r.holes === 9 ? netto * 2 : netto;
                });
            
                const avgNettoLast5 = (nettoLast5.reduce((a, b) => a + b, 0) / 5).toFixed(1);
            
                // Zielbedingung: im Schnitt ca. auf oder unter Vorgabe (Fenster -5 bis +5)
                if (parseFloat(avgNettoLast5) >= -5 && parseFloat(avgNettoLast5) <= 5) {
                    const sign = parseFloat(avgNettoLast5) > 0 ? '+' : '';
                    goalText = `Netto letzte 5: ${sign}${avgNettoLast5} ‚Äì Ziel: konstant unter Vorgabe spielen!`;
                    goalPriority = 40;
                }
            }
        
            if (goalPriority < 35 && rounds.length >= 3) {
                const last3 = rounds.slice(-3);
                const consistentRounds = last3.filter(r => r.scoreDifferential < 5.0).length;
                if (consistentRounds > 0 && consistentRounds < 3) {
                    goalText = `üíé Ziel: 3 Runden hintereinander mit SD < 5,0 (aktuell: ${consistentRounds}/3)`;
                    goalPriority = 35;
                }
            }
        
            if (goalPriority < 20 && rounds.length >= 10) {
                const last10Official = allOfficialRounds.slice(-10);
                if (last10Official.length >= 10) {
                    if (Math.abs(parseFloat(monthChange)) < 0.5) {
                        goalText = `Seit 10 Runden ohne gro√üe √Ñnderung ‚Äì Zeit f√ºr neuen Impuls? üìö`;
                        goalPriority = 20;
                    }
                }
            }
        
            if (nextGoalEl) nextGoalEl.textContent = goalText;
        
            // =========================================================
            // HTML-Ausgabe: ALLGEMEINE STATISTIK
            // =========================================================
        
            generalStats.innerHTML = `
                <div style="font-size: 11px; color: var(--color-text-secondary); text-align: right; margin-bottom: 4px; opacity: 0.7;">
                    Basis: letzte ${recent20.length} Runde${recent20.length !== 1 ? 'n' : ''} (wie WHS)
                </div>
                <div class="stat-row">
                    <span class="stat-label">√ò Schl√§ge</span>
                    <span class="stat-data">${scoringAvgText}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">√ò Score Differential</span>
                    <span class="stat-data">${avgSD}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Beste Runde</span>
                    <span class="stat-data" style="color: var(--color-primary)">${bestRoundText}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Schw√§chste Runde</span>
                    <span class="stat-data">${worstRoundText}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Schwankungsbreite (80%)</span>
                    <span class="stat-data">${consistencyText}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Unter HCP gespielt</span>
                    <span class="stat-data">${underPar} von ${recent20.length} (${((underPar / recent20.length) * 100).toFixed(0)}%)</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Beste Serie</span>
                    <span class="stat-data">${seriesText}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">HCP verbessert sich bei</span>
                    <span class="stat-data" style="color: var(--color-primary); font-weight: 600;">${nextImprovementText}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Seit letzter HCP-√Ñnderung</span>
                    <span class="stat-data">${roundsSinceChange}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Runden</span>
                    <span class="stat-data">${rounds18.length} (18L) / ${rounds9.length} (9L)</span>
                </div>
                ${unofficialRounds.length > 0 && officialRounds.length > 0 ? `
                <div class="stat-row">
                    <span class="stat-label">Performance unter Druck</span>
                    <span class="stat-data" style="color: ${pressureColor}">${pressureText}</span>
                </div>` : ''}
            `;
        
            // =========================================================
            // HTML-Ausgabe: PLATZ-STATISTIK (letzte 20 Runden)
            // =========================================================
        
            const coursesPlayed = {};
            recent20.forEach(r => {
                const key = `${r.course}-${r.holes}L`;
                if (!coursesPlayed[key]) {
                    coursesPlayed[key] = { name: r.course, holes: r.holes, count: 0, strokes: [], scoreDiffs: [], rounds: [] };
                }
                coursesPlayed[key].count++;
                coursesPlayed[key].strokes.push(r.strokes);
                coursesPlayed[key].scoreDiffs.push(r.scoreDifferential);
                coursesPlayed[key].rounds.push(r);
            });
        
            const allCourseEntries = Object.entries(coursesPlayed).sort((a, b) => b[1].count - a[1].count);
            const showAllCourses = window.showAllCoursesStats || false;
        
            const showAllCoursesBtn = document.getElementById('showAllCoursesStatsBtn');
            if (showAllCoursesBtn) {
                if (allCourseEntries.length > 5) {
                    showAllCoursesBtn.style.display = 'block';
                    showAllCoursesBtn.textContent = showAllCourses ? 'Weniger anzeigen' : 'Alle Pl√§tze anzeigen';
                } else {
                    showAllCoursesBtn.style.display = 'none';
                }
            }
        
        const displayCoursesArr = showAllCourses ? allCourseEntries : allCourseEntries.slice(0, 5);
        
        const courseStatsHtml = displayCoursesArr
            .map(([key, data]) => {
                const avgSDCourse = (data.scoreDiffs.reduce((a, b) => a + b, 0) / data.count).toFixed(1);
                
                // ‚úÖ WHS-Performance mit AKTUELLEM Handicap
                const courseInfo = courses.find(c => c.name === data.name && c.holes === data.holes);
                let avgWHS = '-';
                let whsColor = 'var(--color-text-secondary)';
                let whsText = '-';
                
                if (courseInfo) {
    const is9 = data.holes === 9;
    let adjustedIndex = myGolfer.handicapIndex;
    if (is9) adjustedIndex = adjustedIndex / 2;
    
    const currentCourseHcp = calculateCourseHandicap(
        adjustedIndex, 
        courseInfo.sr, 
        courseInfo.cr, 
        courseInfo.par
    );
    
    // ‚úÖ FIX 5: Normalisierung auf 18-Loch f√ºr Vergleichbarkeit
    const whsPerformance = data.rounds.map(r => {
        const allowedStrokes = courseInfo.par + currentCourseHcp;
        const netto = r.strokes - allowedStrokes;
        // 9-Loch auf 18-Loch normalisieren
        return is9 ? netto * 2 : netto;
    });
    avgWHS = (whsPerformance.reduce((a, b) => a + b, 0) / data.count).toFixed(1);
    
    const whsValue = parseFloat(avgWHS);
    if (whsValue <= -5) {
        whsColor = 'var(--color-primary)';   // Deutlich besser als Vorgabe
    } else if (whsValue <= 5) {
        whsColor = 'var(--color-text-secondary)';  // Im Rahmen
    } else {
        whsColor = 'var(--color-danger)';    // Deutlich schlechter
    }
    
    whsText = whsValue > 0 ? `+${avgWHS}` : avgWHS;
}
        
                const coursePar = courseInfo ? courseInfo.par : (data.holes === 9 ? 36 : 72);
                const avgStrokes = (data.strokes.reduce((a, b) => a + b, 0) / data.count).toFixed(0);
                const bestSDCourse = Math.min(...data.scoreDiffs);
                const bestRoundC = data.rounds.find(r => r.scoreDifferential === bestSDCourse);
                const bestStrokes = bestRoundC ? bestRoundC.strokes : Math.min(...data.strokes);
                const bestToPar = bestStrokes - coursePar;
                const bestToParText = bestToPar > 0 ? `+${bestToPar}` : bestToPar.toString();
                const bestDate = bestRoundC ? bestRoundC.date : '';
                const displayName = `${data.name} (${data.holes}L)`;
                
                return `
                    <div class="course-stats-item">
                        <div style="font-weight: 600; font-size: 0.85em; margin-bottom: 5px">${displayName}</div>
                        <div style="font-size: 0.85em; color: var(--color-text-secondary)">
                            ${data.count}x gespielt ‚Ä¢ √ò ${avgStrokes} Schl√§ge<br>
                            <span style="color: ${whsColor}; font-weight: 600">Netto-Performance: ${whsText}</span><br>
                            <strong>Beste:</strong> ${bestStrokes} Schl√§ge (${bestToParText})${bestDate ? ` ‚Ä¢ ${bestDate}` : ''}
                        </div>
                    </div>
                `;
            })
            .join('');
        
        
        
            courseStats.innerHTML = courseStatsHtml || `<div style="text-align:center;color:var(--color-text-secondary);padding:20px">Keine Platzdaten</div>`;
        
            // =========================================================
            // HTML-Ausgabe: TREND-ANALYSE
            // =========================================================
        
            trendStats.innerHTML = `
                <div class="stat-row">
                    <span class="stat-label">${trendEmoji} Handicap-Entwicklung</span>
                    <span class="stat-data" style="color: ${hcpChange < 0 ? 'var(--color-primary)' : hcpChange > 0 ? 'var(--color-danger)' : 'var(--color-warning)'}">
                        ${hcpStart.toFixed(1)} ‚Üí ${hcpCurrent.toFixed(1)} (${hcpChange > 0 ? '+' : ''}${hcpChange})
                    </span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìÖ Letzte 30 Tage</span>
                    <span class="stat-data" style="color: ${monthChange < 0 ? 'var(--color-primary)' : monthChange > 0 ? 'var(--color-danger)' : 'var(--color-warning)'}">
                        ${monthEmoji} ${monthChange > 0 ? '+' : ''}${monthChange} ‚Ä¢ ${monthText}
                    </span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Verbesserungsrate</span>
                    <span class="stat-data" style="color: ${improvementColor}">${improvementText}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">√ò SD (letzte 10)</span>
                    <span class="stat-data" style="color: ${sdLast10Color}">${avgSDLast10}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Form-Momentum</span>
                    <span class="stat-data" style="color: ${momentumColor}">${momentumText}</span>
                </div>
                ${bestMonth !== null ? `
                <div class="stat-row">
                    <span class="stat-label">üåû Bester Monat</span>
                    <span class="stat-data">${bestMonthText}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚ùÑÔ∏è Schw√§chster Monat</span>
                    <span class="stat-data">${worstMonthText}</span>
                </div>` : ''}
            `;
        }
        
                function getPlayingCourseHandicap(round, course, handicapIndex) {
                    if (!course) return 0;
                
                    const is9 = round.holes === 9;
                
                    // Par/CR/SR aus dem Kursobjekt
                    const par = course.par;
                    const cr  = course.cr;
                    const sr  = course.sr;
                
                    // 9-Loch: halbes Handicap Index
                    let adjustedIndex = handicapIndex;
                    if (is9) {
                        adjustedIndex /= 2; // WHS: 9-Loch = halbes HCPI [web:81]
                    }
                
                    return calculateCourseHandicap(adjustedIndex, sr, cr, par);
                }
                
        function renderRounds() {
            const rounds = [...myGolfer.rounds]
                .sort((a, b) => new Date(b.date) - new Date(a.date));
        
            const container = document.getElementById('roundList');
        
            if (rounds.length === 0) {
                container.innerHTML = `<div style="text-align:center;color:var(--color-text-secondary);padding:40px;">Noch keine Runden erfasst</div>`;
                document.getElementById('showAllRoundsBtn').style.display = 'none';
                return;
            }
        
            const countedRoundIds = myGolfer.countedRoundIds || [];
        
            const showAllBtn = document.getElementById('showAllRoundsBtn');
            const showAll = window.showAllRounds || false;
        
            if (rounds.length > 5) {
                showAllBtn.style.display = 'block';
                showAllBtn.textContent = showAll ? 'üìã Weniger anzeigen' : 'üìã Alle Runden anzeigen';
            } else {
                showAllBtn.style.display = 'none';
            }
        
            const displayRounds = (showAll || rounds.length <= 5) ? rounds : rounds.slice(0, 5);
        
        container.innerHTML = displayRounds.map((r) => {
            const course = courses.find(c => c.name === r.course && c.holes === r.holes);
            const coursePar = course ? course.par : (r.holes === 9 ? 36 : 72);
        
            // Brutto: Differenz zu Par
            const diffToPar = r.strokes - coursePar;
            let diffToParText;
            let parColor = 'var(--color-text-secondary)';
            if (diffToPar === 0) {
                diffToParText = 'Even Par';
                parColor = 'var(--color-primary)'; // Even Par = gut
            } else if (diffToPar > 0) {
                diffToParText = `+${diffToPar} √ºber Par`;
                parColor = 'var(--color-danger)'; // √ºber Par = schlecht
            } else {
                diffToParText = `${Math.abs(diffToPar)} unter Par`;
                parColor = 'var(--color-primary)'; // unter Par = gut
            }
        // Netto: Historisches HCP verwenden
        let diffToVorgabe = 0;
        let diffToVorgabeText = '-';
        let color = 'var(--color-text-secondary)';
        if (course) {
            let playingHcp;
            if (r.courseHandicap !== undefined) {
                playingHcp = r.courseHandicap;
            } else {
                playingHcp = getPlayingCourseHandicap(r, course, r.playingHcp);
            }
            const allowedStrokes = coursePar + playingHcp;
            diffToVorgabe = r.strokes - allowedStrokes;
            diffToVorgabeText = diffToVorgabe > 0 ? `+${diffToVorgabe}` : `${diffToVorgabe}`;
        
        // === AMPEL-SYSTEM ===
        if (diffToVorgabe < 0) {
            color = 'var(--color-primary)';   // Gr√ºn: besser als Vorgabe
        } else if (diffToVorgabe <= 2) {
            color = 'var(--color-warning)';   // Gelb: 0, +1, +2
        } else {
            color = 'var(--color-danger)';    // Rot: +3 oder schlechter
        }
        
        // Par-Farbe folgt dem Ampel-System
        parColor = color;
        }
        
            const isCounted = countedRoundIds.includes(r.id);
            const countedBadge = isCounted ? ' ‚òÜ' : '';
            const isOfficial = r.official !== false;
            const historicHcp = r.playingHcp !== undefined ? r.playingHcp.toFixed(1) : '-';
            const hcpiLabel = isOfficial ? '<span style="color: var(--color-text-secondary); font-weight: 600;"> ‚Ä¢ HCPI</span>' : '';
        
            return `
        <div class="round-item" onclick="this.classList.toggle('active'); event.stopPropagation();">
            <div style="flex: 1; min-width: 0;">
                <div style="font-size: 13px; color: var(--color-text-secondary);">
                    ${r.date} ‚Ä¢ HCP ${historicHcp}${countedBadge}
                </div>
                <div style="font-weight: 500; font-size: 15px; margin: 2px 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                    ${r.course}
                </div>
                <div style="font-size: 13px; color: var(--color-text-secondary);">
                    ${r.holes}L ‚Ä¢ ${r.strokes} Schl√§ge${hcpiLabel}
                </div>
            </div>
           <div class="round-scores" style="text-align: right;">
                <div>
                    <div style="font-size: 18px; font-weight: bold; color: ${color};">
                        ${diffToVorgabeText}
                        <span style="font-size: 12px; font-weight: 400; color: var(--color-text-secondary);">Netto</span>
                    </div>
                    <div style="font-size: 14px; color: ${parColor};">${diffToParText}</div>
                </div>
                <div class="round-actions">
                    <button onclick="event.stopPropagation(); editRound('${r.id}')" class="small" 
                        style="background:var(--color-border);color:var(--color-text-secondary);font-size:14px;padding:4px 6px;line-height:1;" 
                        title="Bearbeiten">‚úèÔ∏è</button>
                    <button onclick="event.stopPropagation(); deleteRound('${r.id}')" class="small"
                        style="background:var(--color-border);color:var(--color-text-secondary);font-size:14px;padding:4px 6px;line-height:1;" 
                        title="Runde l√∂schen">üóëÔ∏è</button>
                </div>
            </div>
        </div>
        
                `;
            }).join('');
        }
        
                function toggleAllRounds() {
                    window.showAllRounds = !window.showAllRounds;
                    renderRounds();
                    
                    // Scroll sanft zum Button wenn "weniger anzeigen" geklickt wurde
                    if (!window.showAllRounds) {
                        const btn = document.getElementById('showAllRoundsBtn');
                        if (btn) {
                            btn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                }
                
                function toggleAllCoursesStats() {
                    window.showAllCoursesStats = !window.showAllCoursesStats;
                        renderAdvancedStats();
                }
        
        
                function toggleAllCourses() {
                    window.showAllCourses = !window.showAllCourses;
                    renderCourses();
                }
        
         function editRound(roundId) {
            const round = myGolfer.rounds.find(r => r.id === roundId);
            if (!round) return;
        
            const newStrokes = prompt('Schl√§ge √§ndern:', round.strokes);
            if (newStrokes === null) return;
        
            const newDate = prompt('Datum √§ndern (YYYY-MM-DD):', round.date);
            if (newDate === null) return;
        
            const strokes = parseInt(newStrokes);
            const holes = round.holes || 18;
            const validationErrors = validateRoundData(strokes, holes, newDate);
            if (validationErrors.length > 0) {
                return alert('‚ùå Eingabefehler:\n\n' + validationErrors.join('\n'));
            }
        
            // Pr√ºfe Datumsformat (YYYY-MM-DD)
            const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
            if (!dateRegex.test(newDate) || isNaN(new Date(newDate).getTime())) {
                return alert('‚ùå Ung√ºltiges Datumsformat!\nBitte YYYY-MM-DD verwenden (z.B. 2025-06-15)');
            }
        
            // Update nur die Basis-Daten
            round.strokes = strokes;
            round.date = newDate;
        
            // recalculateHistory berechnet SD, HCP, courseHandicap etc. korrekt
            recalculateHistory();
            
            // WICHTIG: Wird von recalculateHistory schon gemacht!
            // Aber doppelt schadet nicht
            localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
            updateUI();
            alert('‚úÖ Runde aktualisiert!');
        }
                
        function deleteRound(roundId) {
            if (!confirm('Diese Runde wirklich l√∂schen?\n\nDein Handicap wird neu berechnet.')) return;
            myGolfer.rounds = myGolfer.rounds.filter(r => r.id !== roundId);
        
                if (myGolfer.rounds.length === 0) {
                    myGolfer.handicapIndex = myGolfer.startHcp;
                    myGolfer.unofficialHandicap = myGolfer.startHcp;
                    myGolfer.lowestHandicapIndex = myGolfer.startHcp;
                    myGolfer.hcpHistory = [];
                    myGolfer.countedRoundIds = [];
            } else {
                recalculateHistory();
            }
        
            localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
            updateUI();
            alert('‚úÖ Runde gel√∂scht und Handicap neu berechnet!');
        }
                
                function renderChart() {
                    const rounds = myGolfer.rounds.slice(-10).sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    if (rounds.length < 2) return;
                    
                    const canvas = document.getElementById('hcpCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Responsive Canvas-Gr√∂√üe mit HiDPI-Unterst√ºtzung
                    const container = canvas.parentElement;
                    const containerWidth = container.clientWidth - 40;
                    const isMobile = window.innerWidth <= 768;
                    const dpr = window.devicePixelRatio || 1;
        
                    // CSS-Gr√∂√üe setzen
                    canvas.style.width = Math.min(containerWidth, 600) + 'px';
                    canvas.style.height = (isMobile ? 250 : 300) + 'px';
        
                    // Mobile: Leicht kleinere interne Gr√∂√üe f√ºr bessere Performance
                    const scaleFactor = isMobile ? 0.8 : 1;
                    canvas.width = Math.min(containerWidth, 600) * dpr * scaleFactor;
                    canvas.height = (isMobile ? 250 : 300) * dpr * scaleFactor;
        
                    const width = canvas.width;
                    const height = canvas.height;
            
                    // CSS-Koordinaten f√ºr Zeichenbefehle (nach ctx.scale)
                    const cssW = width / (dpr * scaleFactor);
                    const cssH = height / (dpr * scaleFactor);
        
                    // Skalierung f√ºr HiDPI
                    ctx.scale(dpr * scaleFactor, dpr * scaleFactor);
                    
                    // Padding und Chart-Gr√∂√üe f√ºr HiDPI anpassen
                    const padding = { left: 50, right: 30, top: 30, bottom: 40 };
                    const chartWidth = (width / (dpr * scaleFactor)) - padding.left - padding.right;
                    const chartHeight = (height / (dpr * scaleFactor)) - padding.top - padding.bottom;
        
                    // Sch√§rfere Linien und Text f√ºr HiDPI
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // Sammle HISTORISCHE HCP-Werte aus den Runden
                    const unofficialHistory = [];
                    const officialHistory = [];
                    
                    for (let i = 0; i < rounds.length; i++) {
                        const round = rounds[i];
                        
                    // Inoffizielles HCP nach dieser Runde (WHS-KORREKT!)
                    // Berechne mit allen Runden bis zu diesem Zeitpunkt
                    const tempAllRounds = myGolfer.rounds
                        .filter(r => new Date(r.date) <= new Date(round.date))
                        .slice(-20)
                        .map(r => ({ id: r.id, sd: r.scoreDifferential }))
                        .sort((a, b) => a.sd - b.sd);
                    
                    if (tempAllRounds.length === 0) {
                        unofficialHistory.push(myGolfer.startHcp);
                    } else if (tempAllRounds.length < 3) {
                        // Bei <3 Runden: Start-HCP
                        unofficialHistory.push(myGolfer.startHcp);
                    } else {
                    const count = tempAllRounds.length;
                    const { numCounted, adjustment } = getWHSParameters(count);
        
                    const bestRounds = tempAllRounds.slice(0, numCounted);
                        let newHcp = bestRounds.reduce((a, b) => a + b.sd, 0) / numCounted;
                        
                        // Soft Cap anwenden
                        // ‚úÖ FIX 1: 12-Monats-Fenster f√ºr Chart
                        const lowestHcp = getLowestHcpLast12Months(
                            round.date,
                            myGolfer.hcpHistory || [],
                            myGolfer.startHcp
                        );
        
                        // WHS-Reihenfolge: Adjustment ‚Üí Caps
                        newHcp += adjustment;
                        newHcp = Math.round(newHcp * 10) / 10;
                        newHcp = applyCaps(newHcp, lowestHcp);
        
                        unofficialHistory.push(newHcp);
                        }
                        
                    // Offizielles HCP nach dieser Runde (WHS-KORREKT!)
                    const tempOfficialRounds = myGolfer.rounds
                        .filter(r => r.official !== false && new Date(r.date) <= new Date(round.date))
                        .slice(-20)
                        .map(r => ({ id: r.id, sd: r.scoreDifferential }))
                        .sort((a, b) => a.sd - b.sd);
                    
                    if (tempOfficialRounds.length === 0) {
                        officialHistory.push(myGolfer.startHcp);
                    } else if (tempOfficialRounds.length < 3) {
                        // Bei <3 Runden: Start-HCP
                        officialHistory.push(myGolfer.startHcp);
                    } else {
                    const count = tempOfficialRounds.length;
                    const { numCounted, adjustment } = getWHSParameters(count);
        
                    const bestRounds = tempOfficialRounds.slice(0, numCounted);
                        let newHcp = bestRounds.reduce((a, b) => a + b.sd, 0) / numCounted;
        
                        // Soft Cap anwenden
                        // ‚úÖ FIX 1: 12-Monats-Fenster f√ºr Chart (offiziell)
                        const lowestHcp = getLowestHcpLast12Months(
                            round.date,
                            myGolfer.hcpHistory || [],
                            myGolfer.startHcp
                        );

                        // WHS-Reihenfolge: Adjustment ‚Üí Caps
                        newHcp += adjustment;
                        newHcp = Math.round(newHcp * 10) / 10;
                        newHcp = applyCaps(newHcp, lowestHcp);
        
                        officialHistory.push(newHcp);
                    }
                        }
                    
                    if (unofficialHistory.length > 0) {
                        unofficialHistory[unofficialHistory.length - 1] = myGolfer.unofficialHandicap;
                    }
                    if (officialHistory.length > 0) {
                        officialHistory[officialHistory.length - 1] = myGolfer.handicapIndex;
                    }
                       
                    // Finde min/max f√ºr Y-Achse
                    const allValues = [...unofficialHistory, ...officialHistory];
                    const maxHcp = Math.ceil(Math.max(...allValues));
                    const minHcp = Math.floor(Math.min(...allValues));
                    const range = maxHcp - minHcp || 1;
                    
                    ctx.clearRect(0, 0, cssW, cssH);
                    
                    // Zeichne Hintergrund-Gitter und Y-Achsen-Labels
                    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    ctx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.fillStyle = isDark ? '#adb5bd' : '#666';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'right';
                    
                    const steps = Math.min(5, range + 1);
                    for (let i = 0; i <= steps; i++) {
                        const hcpValue = minHcp + (range * i / steps);
                        const y = padding.top + chartHeight - (chartHeight * i / steps);
                        
                        // Horizontale Gitterlinie
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(padding.left, y);
                        ctx.lineTo(cssW - padding.right, y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Y-Achsen-Label
                        ctx.fillText(hcpValue.toFixed(1), padding.left - 10, y + 4);
                    }
                    
                    // Hilfsfunktion: HCP-Wert zu Y-Koordinate
                    const hcpToY = (hcp) => {
                        return padding.top + chartHeight - ((hcp - minHcp) / range) * chartHeight;
                    };
                    
                    // Zeichne OFFIZIELLES HCP (Gr√ºn, dick, durchgezogen)
                    ctx.strokeStyle = '#28a745';
                    ctx.lineWidth = 3.5;
                    ctx.setLineDash([]);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    officialHistory.forEach((hcp, i) => {
                        const x = padding.left + (i / (rounds.length - 1)) * chartWidth;
                        const y = hcpToY(hcp);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                    
                    // Zeichne INOFFIZIELLES HCP (Grau, normal, durchgezogen)
                    ctx.strokeStyle = '#6c757d';
                    ctx.lineWidth = 2.5;
                    
                    ctx.beginPath();
                    unofficialHistory.forEach((hcp, i) => {
                        const x = padding.left + (i / (rounds.length - 1)) * chartWidth;
                        const y = hcpToY(hcp);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                    
                    // Zeichne Punkte NUR bei tats√§chlich gespielten Runden
                    rounds.forEach((round, i) => {
                        const x = padding.left + (i / (rounds.length - 1)) * chartWidth;
                        
                        // Offiziell gespielt? ‚Üí Gr√ºner Punkt
                        if (round.official !== false) {
                            const y = hcpToY(officialHistory[i]);
                            ctx.fillStyle = '#28a745';
                            ctx.beginPath();
                            ctx.arc(x, y, 4, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                        
                        // Inoffiziell gespielt? ‚Üí Grauer Punkt
                        if (round.official === false) {
                            const y = hcpToY(unofficialHistory[i]);
                            ctx.fillStyle = '#6c757d';
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    });
                    
                    // Legende
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'left';
                    
                    // Gr√ºne Linie
                    ctx.strokeStyle = '#28a745';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, cssH - 24);
                    ctx.lineTo(padding.left + 20, cssH - 24);
                    ctx.stroke();
                    ctx.fillStyle = '#28a745';
                    ctx.fillText('Offiziell', padding.left + 25, cssH - 20);
        
                    // Graue Linie
                    ctx.strokeStyle = '#6c757d';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(padding.left + 120, cssH - 24);
                    ctx.lineTo(padding.left + 140, cssH - 24);
                    ctx.stroke();
                    ctx.fillStyle = '#6c757d';
                    ctx.fillText('Inoffiziell', padding.left + 145, cssH - 20);
        
                }
                
                    function addCourse() {
                        const name = document.getElementById('courseName').value.trim();
                        const crRaw = document.getElementById('courseCR').value.replace(',', '.');
                        const cr = parseFloat(crRaw);
                        const sr = parseInt(document.getElementById('courseSR').value);
                        const holes = parseInt(document.querySelector('input[name="courseHoles"]:checked').value);
                        const parRaw = document.getElementById('coursePar').value.replace(',', '.');
                        const par = parseInt(parRaw) || (holes === 9 ? 36 : 72);
                        
                        if (!name || isNaN(cr) || isNaN(sr) || cr < 20 || sr < 55 || sr > 155) {
                            return alert('Bitte korrekte Platzdaten eingeben!\n(CR min. 20, SR 55-155)');
                        }
                        
                        // Duplikat-Pr√ºfung: gleicher Name + gleiche Lochzahl
                        const duplicate = courses.find(c => c.name.toLowerCase() === name.toLowerCase() && c.holes === holes);
                        if (duplicate) {
                            if (!confirm(`‚ö†Ô∏è Ein Platz "${duplicate.name}" mit ${holes} L√∂chern existiert bereits!\n\nCR ${duplicate.cr.toFixed(1)} / SR ${duplicate.sr} / Par ${duplicate.par}\n\nTrotzdem einen weiteren Eintrag anlegen?`)) {
                                return;
                            }
                        }
                        
                        courses.push({
                            id: generateUniqueId(),
                            name: name,
                            cr: cr,
                            sr: sr,
                            holes: holes,
                            par: par
                        });
        
                
                        saveCourses();
                        updateUI();
                        
                        document.getElementById('courseName').value = '';
                        document.getElementById('courseCR').value = '';
                        document.getElementById('courseSR').value = '';
                        document.getElementById('coursePar').value = '';
        
                        
                        alert(`${name} wurde gespeichert!`);
                    }
            
          
                      function editCourse(courseId) {
                        const course = courses.find(c => c.id === courseId);
                        if (!course) return;
                    
                        const oldName = course.name;
                        const newName = prompt('Platzname √§ndern:', course.name);
                        if (newName === null) return;
        
                        const newHoles = prompt('Lochzahl √§ndern (9 oder 18):', course.holes || 18);
                        if (newHoles === null) return;
                    
                        const holes = parseInt(newHoles);
                        if (holes !== 9 && holes !== 18) {
                            return alert('Lochzahl muss 9 oder 18 sein!');
                        }
                          
                        const newPar = prompt('Par √§ndern:', course.par || (holes === 9 ? 36 : 72));
                        if (newPar === null) return;
                          
                        const par = parseInt(newPar);
                        if (isNaN(par) || par < 27 || par > 90) {
                            return alert('Par muss zwischen 27 und 90 liegen!');
                        }
                    
                        const newCR = prompt('Course Rating √§ndern:', course.cr);
                        if (newCR === null) return;
                    
                        const newSR = prompt('Slope Rating √§ndern:', course.sr);
                        if (newSR === null) return;
                          
                        const cr = parseFloat(newCR.replace(',', '.'));
                        const sr = parseInt(newSR);
                    
                        if (!newName.trim() || isNaN(cr) || isNaN(sr) || cr < 20 || sr < 55 || sr > 155) {
                            return alert('Ung√ºltige Eingaben! (CR min. 20, SR 55-155)');
                        }
                    
                                const oldCR = course.cr;
                                const oldSR = course.sr;
                                const oldHoles = course.holes || 18;
                        
                                course.name = newName.trim();
                                course.holes = holes;
                                course.par = par;
                                course.cr = cr;
                                course.sr = sr;
        
                        
                                const usedInRounds = myGolfer.rounds.filter(r => r.course === oldName && r.holes === oldHoles);
                          
                        // Tracke ob Name/Holes in Runden aktualisiert wurden
                        let roundsNameUpdated = false;
                        let roundsHolesUpdated = false;

                        if (usedInRounds.length > 0) {
                                const nameChanged = oldName !== newName.trim();
                                const holesChanged = oldHoles !== holes;
                                if (nameChanged || holesChanged) {
                                    const changes = [];
                                    if (nameChanged) changes.push('Name');
                                    if (holesChanged) changes.push('Lochzahl');
                                    if (confirm(`${usedInRounds.length} Runden verwenden diesen Platz. ${changes.join(' und ')} in allen Runden aktualisieren?`)) {
                                        usedInRounds.forEach(round => {
                                            if (nameChanged) { round.course = newName.trim(); roundsNameUpdated = true; }
                                            if (holesChanged) { round.holes = holes; roundsHolesUpdated = true; }
                                        });
                                    }
                                }
                    
                    if (oldCR !== cr || oldSR !== sr) {
                        // Finde nur Runden die tats√§chlich zu diesem Platz geh√∂ren
                        // (entweder mit aktualisiertem oder altem Namen, je nachdem was der User gew√§hlt hat)
                        const matchName = roundsNameUpdated ? newName.trim() : oldName;
                        const matchHoles = roundsHolesUpdated ? holes : oldHoles;
                        const roundsToRecalc = myGolfer.rounds.filter(r => 
                            r.course === matchName && r.holes === matchHoles
                        );
                        roundsToRecalc.forEach(round => {
                            // Nur Basisdaten aktualisieren - SD wird durch recalculateHistory korrekt berechnet
                            round.cr = cr.toFixed(1);
                            round.sr = sr.toFixed(0);
                        });
                        // recalculateHistory berechnet SD inkl. 9-Loch-Konvertierung
                        recalculateHistory();
                        updateUI();
                        alert(`Platz wurde aktualisiert!\n${roundsToRecalc.length} Runden wurden mit neuen CR/SR-Werten neu berechnet.\nHandicap wurde aktualisiert.`);
                        return;
                    }
                            localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
                        }
                    
                        saveCourses();
                        updateUI();
                        alert('Platz wurde aktualisiert!');
                    }
        
        function deleteCourse(courseId) {
            const course = courses.find(c => c.id === courseId);
            if (!course) return;
            
            // üîß Null-Check + holes pr√ºfen + Daten-Validierung
            let affectedRounds = [];
            if (myGolfer && myGolfer.rounds && Array.isArray(myGolfer.rounds)) {
                affectedRounds = myGolfer.rounds.filter(r => 
                    r && r.course === course.name && r.holes === course.holes
                );
            }
            
            let confirmMsg = `Platz "${course.name}" (${course.holes} L√∂cher) wirklich l√∂schen?`;
            
            if (affectedRounds.length > 0) {
                // üîß Beispiel-Datum mit Fallback
                let dateText = '';
                try {
                    if (affectedRounds[0] && affectedRounds[0].date) {
                        const date = new Date(affectedRounds[0].date);
                        if (!isNaN(date.getTime())) {
                            dateText = `\n(z.B. am ${date.toLocaleDateString('de-DE')})`;
                        }
                    }
                } catch (e) {
                    // Ignoriere Datum-Fehler
                }
                
                confirmMsg += `\n\n‚ö†Ô∏è ACHTUNG: Dieser Platz wurde in ${affectedRounds.length} Runde(n) verwendet!${dateText}\n\n` +
                              `Die Runden bleiben erhalten, aber der Platz wird aus der Liste entfernt.\n` +
                              `Bei Statistiken wird "${course.name}" dann als "unbekannter Platz" angezeigt.\n\n` +
                              `WIRKLICH L√ñSCHEN?`;
            }
            
            if (!confirm(confirmMsg)) return;
            
            courses = courses.filter(c => c.id !== courseId);
            saveCourses();
            updateUI();
            alert('‚úÖ Platz wurde gel√∂scht!');
        }
        
        function showEditProfile() {
          const newName = prompt("Name √§ndern", myGolfer.name);
          if (newName === null) return; // Abbruch ‚Üí nichts √§ndern
          
          const newClub = prompt("Club √§ndern", myGolfer.club);
          if (newClub === null) return; // Abbruch ‚Üí nichts √§ndern
          
          if (newName.trim()) {
            myGolfer.name = newName.trim();
          } else {
            return alert('Name darf nicht leer sein!');
          }
          myGolfer.club = newClub.trim();
          
          localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
          updateUI();
          alert('‚úÖ Profil wurde gespeichert!');
        }
        
                
                function exportData() {
                    const data = {
                        golfer: myGolfer,
                        courses: courses,
                        exportDate: new Date().toISOString().split('T')[0],
                        appVersion: '2.1'
                    };
                    
                    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `mein-golf-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    alert('‚úÖ Daten wurden exportiert!');
                }
                
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validierung
                    if (!data.golfer || !data.golfer.rounds || !Array.isArray(data.golfer.rounds)) {
                        throw new Error('Ung√ºltiges Datenformat');
                    }
                    
                    // Vorschau mit Best√§tigung
                    confirmImport(data, function(confirmedData) {
                        myGolfer = confirmedData.golfer;
                        courses = confirmedData.courses;
                        
                        // üîß ID-Normalisierung VOR dem Speichern
                        if (courses && Array.isArray(courses)) {
                            courses = courses.map(c => ({
                                ...c,
                                id: String(c.id)
                            }));
                        }
                        
                        if (myGolfer && myGolfer.rounds && Array.isArray(myGolfer.rounds)) {
                            myGolfer.rounds = myGolfer.rounds.map(r => ({
                                ...r,
                                id: String(r.id)
                            }));
                        }
                        
                        localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
                        saveCourses();
                        checkSetup();
                        alert(`‚úÖ Import erfolgreich!\n\nSpieler: ${myGolfer.name || 'Unbekannt'}\nHandicap: ${myGolfer.handicapIndex.toFixed(1)}\nRunden: ${myGolfer.rounds ? myGolfer.rounds.length : 0}`);
                    });
                    
                } catch(err) {
                    alert('‚ùå Import-Fehler: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }
        
        function setupImportData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validierung
                    if (!data.golfer || !data.golfer.rounds || !Array.isArray(data.golfer.rounds)) {
                        throw new Error('Ung√ºltiges Datenformat - golfer.rounds fehlt oder ist kein Array.');
                    }
                    
                    // Direkter Import ohne Best√§tigung (Ersteinrichtung)
                    myGolfer = data.golfer;
                    courses = data.courses;
                    
                    // üîß ID-Normalisierung VOR dem Speichern
                    if (courses && Array.isArray(courses)) {
                        courses = courses.map(c => ({
                            ...c,
                            id: String(c.id)
                        }));
                    }
                    
                    if (myGolfer && myGolfer.rounds && Array.isArray(myGolfer.rounds)) {
                        myGolfer.rounds = myGolfer.rounds.map(r => ({
                            ...r,
                            id: String(r.id)
                        }));
                    }
                    
                    localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
                    saveCourses();
                    
                    alert(`‚úÖ Import erfolgreich!\n\nSpieler: ${myGolfer.name || 'Unbekannt'}\nHandicap: ${myGolfer.handicapIndex.toFixed(1)}\nRunden: ${myGolfer.rounds ? myGolfer.rounds.length : 0}\nPl√§tze: ${Array.isArray(courses) ? courses.length : 0}`);
                    
                    checkSetup();
                    
                } catch(err) {
                    console.error('Setup Import failed:', err);
                    alert('‚ùå Import-Fehler: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset
        }
                
                function showHandicapCalculation() {
                // 1. Hole alle offiziellen Runden (max. 20, sortiert nach Score Differential)
                const officialRounds = myGolfer.rounds
                    .filter(r => r.official !== false)
                    .slice(-20)
                    .map(r => ({ 
                        id: r.id,
                        date: r.date, 
                        course: r.course, 
                        holes: r.holes,
                        strokes: r.strokes,
                        sd: r.scoreDifferential,
                        sd9: r.scoreDifferential9,
                        playingHcp: r.playingHcp
                    }))
                    .sort((a, b) => a.sd - b.sd);
                
                    if (officialRounds.length === 0) {
                        alert("Keine offiziellen Runden vorhanden!\n\nDein Handicap basiert auf dem Startwert: " + myGolfer.startHcp.toFixed(1));
                        return;
                    }
                
                    const count = officialRounds.length;
                    
                    // Bei weniger als 3 Runden: Start-HCP bleibt
                    if (count < 3) {
                        alert(`WHS HANDICAP-BERECHNUNG\n\nDu hast erst ${count} offizielle Runde${count > 1 ? 'n' : ''}.\n\nMindestens 3 Runden sind n√∂tig f√ºr die Berechnung.\nBis dahin gilt dein Start-Handicap: ${myGolfer.startHcp.toFixed(1)}`);
                        return;
                    }
                
                    // 2. WHS-Parameter: Wie viele Runden werden gewertet?
                    const { numCounted, adjustment } = getWHSParameters(count);
                    const countedRounds = officialRounds.slice(0, numCounted);
                    const countedIds = countedRounds.map(r => r.id);
                    
                    // 3. Berechne Durchschnitt + Adjustment
                    let avgBest = countedRounds.reduce((a, b) => a + b.sd, 0) / numCounted;
                    const beforeAdj = avgBest;
                    
                    // 4. Adjustment anwenden (VOR Caps)
                    let calculatedHcp = avgBest + adjustment;
                    
                    // 5. Runden auf 0.1
                    calculatedHcp = Math.round(calculatedHcp * 10) / 10;
                    const beforeCap = calculatedHcp;
                    
                    // 6. Soft/Hard Cap
                    const hcpHistory = myGolfer.hcpHistory || [];
                    const now = new Date().toISOString();
                    const lowestHcp12m = getLowestHcpLast12Months(now, hcpHistory, myGolfer.startHcp);
                    const softCapLimit = lowestHcp12m + 3.0;
                    const hardCapLimit = lowestHcp12m + 5.0;
                    const afterCap = applyCaps(calculatedHcp, lowestHcp12m);
                    const capsApplied = afterCap !== beforeCap;
                    
                    // 7. Endergebnis
                    const finalHcp = afterCap;
                    
                    // 8. Pr√ºfe ob ESR (Exceptional Score Reduction) angewendet wurde
                    const storedHcp = myGolfer.handicapIndex;
                    const esrApplied = Math.abs(storedHcp - finalHcp) > 0.05;
                    const displayHcp = storedHcp; // Immer das tats√§chlich gespeicherte HCP anzeigen
                
                    // 8. Finde die Runden die als n√§chstes "rausfallen"
                    const allOfficialByDate = myGolfer.rounds
                        .filter(r => r.official !== false)
                        .slice(-20)
                        .sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    const nextToFallOut = allOfficialByDate.length >= 20 ? [allOfficialByDate[0]] : [];
                    const fallOutIds = nextToFallOut.map(r => r.id);
                
                    // === TEXT ERSTELLEN ===
                    let msg = "WHS HANDICAP-BERECHNUNG\n";
                        msg += "\n";
                    msg += `Durchschnitt: ${beforeAdj.toFixed(1)}\n`;
                    
                    if (adjustment !== 0) {
                        msg += `WHS-Anpassung: ${adjustment > 0 ? '+' : ''}${adjustment.toFixed(1)}\n`;
                    }
                    
                    msg += `Gerundet: ${beforeCap.toFixed(1)}\n`;
                    
                    if (capsApplied) {
                            msg += `Soft/Hard Cap angewendet (Low HI 12M: ${lowestHcp12m.toFixed(1)})\n`;
                    }
                    
                    if (esrApplied) {
                        msg += `Exceptional Score Reduction: ${finalHcp.toFixed(1)} ‚Üí ${displayHcp.toFixed(1)}\n`;
                    }
                    
                    msg += "\n";
                    msg += `DEIN HANDICAP: ${displayHcp.toFixed(1)}\n`;
                    msg += "\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
                    
                    countedRounds.forEach((r, i) => {
                    const course = courses.find(c => c.name === r.course && c.holes === r.holes);
                    const par = course ? course.par : (r.holes === 9 ? 36 : 72);
                    const toPar = r.strokes - par;
                    const toParText = toPar > 0 ? `+${toPar}` : toPar.toString();
                    // Bei 9-Loch-Runden: zeige auch das rohe 9h-SD
                    const sdText = r.sd9 !== null && r.sd9 !== undefined
                        ? `SD ${r.sd.toFixed(1)} (9L: ${r.sd9.toFixed(1)})`
                        : `SD ${r.sd.toFixed(1)}`;
                    
                    msg += `${i + 1}. ${r.date} ‚Ä¢ ${r.course}\n`;
                    msg += `   ${r.strokes} Schl√§ge (${toParText} zu Par) ‚Ä¢ ${sdText}\n`;
                });
                    
                    msg += "\n";
                    msg += `DEIN HANDICAP: ${displayHcp.toFixed(1)}\n`;
                    msg += "\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
                
                    // Schritt 2: Nicht gewertete Runden
                    const notCounted = officialRounds.filter(r => !countedIds.includes(r.id));
                    if (notCounted.length > 0) {
                        msg += "WEITERE RUNDEN (nicht gewertet)\n";
                        msg += "Diese Runden sind in der Berechnung, z√§hlen aber nicht:\n\n";
                        
                        notCounted.slice(0, 12).forEach(r => {
                            const course = courses.find(c => c.name === r.course && c.holes === r.holes);
                            const par = course ? course.par : (r.holes === 9 ? 36 : 72);
                            const toPar = r.strokes - par;
                            const toParText = toPar > 0 ? `+${toPar}` : toPar.toString();
                            
                            // Markiere ob Runde bald rausf√§llt
                            const willFallOut = fallOutIds.includes(r.id);
                            const marker = willFallOut ? "‚ö†" : "‚Ä¢";
                            
                            msg += `${marker} ${r.date} ‚Ä¢ ${r.course} ‚Ä¢ SD ${r.sd.toFixed(1)}\n`;
                        });
                        
                        if (notCounted.length > 12) {
                            msg += `\n... und ${notCounted.length - 12} weitere\n`;
                        }
                        
                        msg += "\n‚ö† = f√§llt bei n√§chster Runde raus\n";
                    }
                
                    alert(msg);
                }
        
   function recalculateHistory() {
    if (!myGolfer || !myGolfer.rounds || myGolfer.rounds.length === 0) return;

    // 1. Alle Runden nach Datum sortieren
    myGolfer.rounds.sort((a, b) => {
        const dateCompare = new Date(a.date) - new Date(b.date);
        if (dateCompare !== 0) return dateCompare;
        return parseInt(a.id) - parseInt(b.id);
    });

    // 2. Vom Start-HCP aus chronologisch durchrechnen
    let runningHcp = myGolfer.startHcp;
    
    // HCP-History aufbauen (f√ºr 12-Monats-Fenster)
    const hcpHistory = [{ date: myGolfer.created || myGolfer.rounds[0].date, hcp: myGolfer.startHcp }];

    for (let i = 0; i < myGolfer.rounds.length; i++) {
        const round = myGolfer.rounds[i];
        const course = courses.find(c => c.name === round.course && c.holes === round.holes);

        // A) Setze das damalige HCPI
        round.playingHcp = runningHcp;

        // B) Berechne Course Handicap mit damaligem HCPI
        if (course) {
            round.courseHandicap = getPlayingCourseHandicap(round, course, runningHcp);
        }

        // C) Score Differential neu berechnen
        if (course) {
            const rawSD = parseFloat(
                ((round.strokes - course.cr) * (113 / course.sr)).toFixed(1)
            );
            round.cr = course.cr.toFixed(1);
            round.sr = course.sr.toFixed(0);

            // WHS 2024: 9-Loch SD ‚Üí 18-Loch-√Ñquivalent
            if (round.holes === 9) {
                round.scoreDifferential9 = rawSD;
                round.scoreDifferential = convert9HoleTo18HoleSD(rawSD, runningHcp);
            } else {
                round.scoreDifferential = rawSD;
                round.scoreDifferential9 = null;
            }
        }

        // D) HCP nach dieser Runde neu berechnen (nur offizielle)
        const officialSoFar = myGolfer.rounds
            .slice(0, i + 1)
            .filter(r => r.official !== false)
            .slice(-20)
            .map(r => ({ id: r.id, sd: r.scoreDifferential }))
            .sort((a, b) => a.sd - b.sd);

        if (officialSoFar.length >= 3) {
            const { numCounted, adjustment } = getWHSParameters(officialSoFar.length);
            const bestRounds = officialSoFar.slice(0, numCounted);
                let newHcp = bestRounds.reduce((a, b) => a + b.sd, 0) / numCounted;

            // Adjustment anwenden (VOR Caps, wie in updateMyHandicap)
            newHcp += adjustment;
            newHcp = Math.round(newHcp * 10) / 10;

            // Soft/Hard Cap
            const lowestHcp12m = getLowestHcpLast12Months(round.date, hcpHistory, myGolfer.startHcp);
            newHcp = applyCaps(newHcp, lowestHcp12m);

            runningHcp = newHcp;

            // ESR in recalculateHistory
            if (round.official !== false) {
                const esrDiff = round.playingHcp - round.scoreDifferential;
                if (esrDiff >= 10.0) {
                    runningHcp = Math.max(-5.0, runningHcp - 2.0);
                } else if (esrDiff >= 7.0) {
                    runningHcp = Math.max(-5.0, runningHcp - 1.0);
                }
            }
        }

        // HCP-History fortschreiben
        if (round.official !== false) {
            hcpHistory.push({ date: round.date, hcp: runningHcp });
        }
    }

    myGolfer.handicapIndex = runningHcp;
    // Allzeit-Tiefstwert pflegen
    if (myGolfer.lowestHandicapIndex === undefined || runningHcp < myGolfer.lowestHandicapIndex) {
        myGolfer.lowestHandicapIndex = runningHcp;
    }
    // hcpHistory begrenzen: max. 100 Eintr√§ge
    myGolfer.hcpHistory = hcpHistory.length > 100 ? hcpHistory.slice(-100) : hcpHistory;
    updateUnofficialHandicap();

    // Counted Round IDs (vereinfacht ‚Äì keine kombinierten Runden mehr)
    const finalOfficial = myGolfer.rounds
        .filter(r => r.official !== false)
        .slice(-20)
        .map(r => ({ id: r.id, sd: r.scoreDifferential }))
        .sort((a, b) => a.sd - b.sd);

    if (finalOfficial.length >= 3) {
        const { numCounted } = getWHSParameters(finalOfficial.length);
        myGolfer.countedRoundIds = finalOfficial.slice(0, numCounted).map(r => r.id);
    } else {
        myGolfer.countedRoundIds = [];
    }

    localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
}
        
        function manualRecalculate() {
            if (!confirm('Alle Runden chronologisch neu berechnen?\n\nDas korrigiert HCPI, Spielvorgaben und Score Differentials f√ºr alle Runden.')) return;
            
            recalculateHistory();
            updateUI();
            
            alert('‚úÖ Neuberechnung abgeschlossen!\n\n' +
                'Handicap: ' + myGolfer.handicapIndex.toFixed(1) + '\n' +
                'Runden neu berechnet: ' + myGolfer.rounds.length);
        }
        
        // Auto-Focus Einstellung laden
        function loadAutoFocusSetting() {
            const autoFocus = localStorage.getItem('autoFocusStrokes');
            const toggle = document.getElementById('autoFocusToggle');
            if (toggle) {
                toggle.checked = autoFocus === 'true' || autoFocus === null; // Standard: AN
            }
        }
        
        // Auto-Focus Einstellung speichern
        function toggleAutoFocus() {
            const toggle = document.getElementById('autoFocusToggle');
            localStorage.setItem('autoFocusStrokes', toggle.checked);
        }
        
        // Fokus auf Schl√§ge-Feld setzen (wenn Kurs ausgew√§hlt und aktiviert)
        function autoFocusStrokesField() {
            const autoFocus = localStorage.getItem('autoFocusStrokes');
            const shouldFocus = autoFocus === 'true' || autoFocus === null; // Standard: AN
            
            if (shouldFocus) {
                const courseId = document.getElementById('roundCourse').value;
                const strokesInput = document.getElementById('roundStrokes');
                
                if (courseId && strokesInput) {
                    // Kleiner Timeout damit der Browser Zeit hat
                    setTimeout(() => {
                        strokesInput.focus();
                    }, 100);
                }
            }
        }
        
        // Import-Vorschau mit Best√§tigung
        function confirmImport(importedData, callback) {
            // Aktuelle Daten
            const currentName = myGolfer ? myGolfer.name : 'Keine Daten';
            const currentHcp = myGolfer ? myGolfer.handicapIndex.toFixed(1) : '-';
            const currentRounds = myGolfer && myGolfer.rounds ? myGolfer.rounds.length : 0;
            const currentCourses = courses.length;
            
            // Neue Daten
            const newName = importedData.golfer.name || 'Unbekannt';
            const newHcp = importedData.golfer.handicapIndex.toFixed(1);
            const newRounds = importedData.golfer.rounds ? importedData.golfer.rounds.length : 0;
            const newCourses = importedData.courses ? importedData.courses.length : 0;
            
            // Best√§tigungs-Dialog
            const message = 
                'IMPORT BEST√ÑTIGEN\n\n' +
                '--- Neue Daten ---\n' +
                'Spieler: ' + newName + '\n' +
                'Handicap: ' + newHcp + '\n' +
                'Runden: ' + newRounds + '\n' +
                'Pl√§tze: ' + newCourses + '\n\n' +
                '--- Aktuelle Daten (werden √ºberschrieben!) ---\n' +
                'Spieler: ' + currentName + '\n' +
                'Handicap: ' + currentHcp + '\n' +
                'Runden: ' + currentRounds + '\n' +
                'Pl√§tze: ' + currentCourses + '\n\n' +
                'ACHTUNG: Deine aktuellen Daten werden komplett ersetzt!\n\n' +
                'M√∂chtest du fortfahren?';
            
            if (confirm(message)) {
                callback(importedData);
            } else {
                alert('Import abgebrochen. Keine Daten wurden ge√§ndert.');
            }
        }
        
                
                function clearData() {
                    if (confirm('üö® WIRKLICH ALLES L√ñSCHEN?\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) {
                        if (confirm('Letzte Best√§tigung: Alle Daten werden unwiderruflich gel√∂scht!')) {
                            localStorage.removeItem('myGolfer');
                            localStorage.removeItem('courses');
                            localStorage.removeItem('autoFocusStrokes');
                            localStorage.removeItem('iosInstallPromptShown');
                            location.reload();
                        }
                    }
                }
                
                window.addEventListener('DOMContentLoaded', () => {
                    init();
                    
                    // Service Worker f√ºr Offline-Support registrieren
                    if ('serviceWorker' in navigator) {
                        navigator.serviceWorker.register('./sw.js')
                            .then(reg => {
                                console.log('Service Worker registriert:', reg.scope);
                                // Update pr√ºfen
                                reg.addEventListener('updatefound', () => {
                                    const newWorker = reg.installing;
                                    newWorker.addEventListener('statechange', () => {
                                        if (newWorker.state === 'activated' && navigator.serviceWorker.controller) {
                                            console.log('Neue Version verf√ºgbar ‚Äì Seite wird aktualisiert.');
                                        }
                                    });
                                });
                            })
                            .catch(err => console.log('SW Registrierung fehlgeschlagen:', err));
                    }
                    
                    // iOS Safari Installationshinweis
                    if (isIOS() && !isInStandaloneMode()) {
                        setTimeout(() => {
                            showIOSInstallPrompt();
                        }, 2000);
                    }
                });
                
                function isIOS() {
                    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                }
                
                function isInStandaloneMode() {
                    return window.navigator.standalone === true || window.matchMedia('(display-mode: standalone)').matches;
                }
                
                function scrollToAddRound() {
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar) {
                        sidebar.scrollIntoView({ behavior: 'smooth', block: 'start' });
                      }
                }
        
                function showIOSInstallPrompt() {
                    const lastShown = localStorage.getItem('iosInstallPromptShown');
                    const now = new Date().getTime();
                    
                    // Zeige maximal alle 7 Tage
                    if (lastShown && (now - parseInt(lastShown)) < 7 * 24 * 60 * 60 * 1000) {
                        return;
                    }
                    
                    const showPrompt = confirm(
                        'üì± APP INSTALLIEREN (Offline-f√§hig!)\n\n' +
                        'Diese App funktioniert auch ohne Internet!\n' +
                        'F√ºge sie zu deinem Home-Bildschirm hinzu:\n\n' +
                        '1. Tippe auf das Teilen-Symbol (unten in Safari)\n' +
                        '2. Scrolle nach unten\n' +
                        '3. W√§hle "Zum Home-Bildschirm"\n' +
                        '4. Tippe auf "Hinzuf√ºgen"\n\n' +
                        'M√∂chtest du diese Anleitung sp√§ter noch einmal sehen?'
                    );
                    
                    if (!showPrompt) {
                        localStorage.setItem('iosInstallPromptShown', now.toString());
                    }
                }
        
                // Chart bei Fenstergr√∂√üen√§nderung neu zeichnen (mit Debouncing)
                let resizeTimer;
                window.addEventListener('resize', function() {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(function() {
                        if (myGolfer && myGolfer.rounds.length >= 2 && document.getElementById('advancedStats').classList.contains('active')) {
                            renderChart();
                        }
                    }, 250);
                });
        
            </script>
        </body>
        </html>
