<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mein Golf Handicap - DGV/WHS</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Golf HCP">
    <meta name="theme-color" content="#28a745">
    <link rel="apple-touch-icon" href="icon-512.png">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%2328a745' width='100' height='100'/%3E%3Ctext x='50' y='70' font-size='60' text-anchor='middle' fill='white'%3E‚õ≥%3C/text%3E%3C/svg%3E">
    <style>
        :root {
            --color-bg-primary: #f8f9fa;
            --color-surface: white;
            --color-text-primary: #212529;
            --color-text-secondary: #6c757d;
            --color-primary: #28a745;
            --color-primary-hover: #218838;
            --color-accent: #007bff;
            --color-danger: #dc3545;
            --color-danger-hover: #c82333;
            --color-warning: #ffc107;
            --color-border: #dee2e6;
            --color-secondary: #6c757d;
            --color-secondary-hover: #5a6268;
        }
        
        @media (prefers-color-scheme: dark) {
            :root {
                --color-bg-primary: #212529;
                --color-surface: #343a40;
                --color-text-primary: #f8f9fa;
                --color-text-secondary: #adb5bd;
                --color-border: #495057;
            }
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg-primary);
            color: var(--color-text-primary);
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .container {
            display: grid;
            grid-template-columns: 340px 1fr;
            gap: 20px;
            min-height: 100vh;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-auto-flow: dense;
            }
            
            .main {
                order: -1;
            }
        }
        
        .sidebar {
            background: var(--color-surface);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        .main {
            background: var(--color-surface);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: var(--color-primary);
            margin: 0 0 20px 0;
            text-align: center;
            font-size: 1.8em;
            grid-column: 1/-1;
        }
        
        h2 {
            color: var(--color-primary);
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        button {
            background: var(--color-primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: var(--color-primary-hover);
            transform: translateY(-1px);
        }
        
        button.secondary {
            background: var(--color-secondary);
        }
        
        button.secondary:hover {
            background: var(--color-secondary-hover);
        }
        
        button.danger {
            background: var(--color-danger);
        }
        
        button.danger:hover {
            background: var(--color-danger-hover);
        }
        
        button.small {
            width: auto;
            padding: 6px 12px;
            font-size: 12px;
            margin: 0;
        }
        
        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--color-border);
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 14px;
            background: var(--color-bg-primary);
            color: var(--color-text-primary);
            min-height: 44px;
            box-sizing: border-box;
        }

        input[type="date"] {
            padding: 12px 8px 12px 12px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        input[type="date"]::-webkit-calendar-picker-indicator {
            cursor: pointer;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--color-accent);
        }
        
        .card {
            background: var(--color-bg-primary);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid var(--color-primary);
        }
        
        .golfer-info {
            background: linear-gradient(135deg, var(--color-primary), #20c997);
            color: white;
            text-align: center;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .hcp-display {
            font-size: 3em;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .round-list {
            /* max-height: 500px; */
            /* overflow-y: auto; */
        }
        
        .round-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: var(--color-bg-primary);
            margin-bottom: 8px;
            border-radius: 8px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat {
            text-align: center;
            padding: 15px;
            background: var(--color-bg-primary);
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .stat-value {
            font-size: 2.2em;
            font-weight: bold;
            color: var(--color-primary);
            margin-bottom: 5px;
        }
        
        .setup-form {
            background: var(--color-surface);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
            max-width: 400px;
            margin: 50px auto;
            text-align: center;
        }
        
        .setup-form h2 {
            color: var(--color-primary);
            margin-bottom: 20px;
        }
        
        .setup-form input {
            font-size: 16px;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
            margin-bottom: 10px;
        }

        .file-input-wrapper button {
            margin-bottom: 0;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .hcp-boxes {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .hcp-box {
            flex: 1;
            text-align: center;
            padding: 15px;
            color: white;
            border-radius: 12px;
        }
        
        .hcp-box.official {
            background: linear-gradient(135deg, #28a745, #20c997);
        }
        
        .hcp-box.unofficial {
            background: linear-gradient(135deg, #6c757d, #8c96a0);
        }
        
        .hcp-box-label {
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        
        .hcp-box-value {
            font-size: 2em;
            font-weight: bold;
        }
        
        .advanced-stats {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: var(--color-bg-primary);
            border-radius: 12px;
        }
        
        .advanced-stats.active {
            display: block;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            margin-bottom: 8px;
            background: var(--color-surface);
            border-radius: 8px;
            border-left: 3px solid var(--color-primary);
        }
        
        .stat-label {
            font-weight: 600;
            color: var(--color-text-secondary);
        }
        
        .stat-data {
            font-weight: bold;
            color: var(--color-primary);
            font-size: 1.1em;
        }
        
        .course-stats-item {
            padding: 12px;
            background: var(--color-surface);
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--color-accent);
        }
        
        .toggle-stats-btn {
            background: var(--color-surface);
            color: var(--color-text-primary);
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        /* Desktop: Sichtbarer Hover */
        @media (hover: hover) and (pointer: fine) {
            .toggle-stats-btn:hover {
                background: #d0d4d9;
            }
        }
        
        /* Desktop Dark Mode */
        @media (hover: hover) and (pointer: fine) and (prefers-color-scheme: dark) {
            .toggle-stats-btn:hover {
                background: #4a5460;
            }
        }
        
        /* Desktop: Active Feedback */
        @media (hover: hover) and (pointer: fine) {
            .toggle-stats-btn:active {
                transform: scale(0.98);
            }
        }
        
        /* Mobile: Kurzer Feedback-Flash */
        @media (hover: none) {
            .toggle-stats-btn:hover,
            .toggle-stats-btn:focus,
            .toggle-stats-btn:focus-visible,
            .toggle-stats-btn:focus-within {
                background: var(--color-surface) !important;
                outline: none !important;
            }
            
            .toggle-stats-btn:active {
                background: rgba(0, 0, 0, 0.05) !important;
                transform: scale(0.98) !important;
                transition: none !important;
            }
        }
        
        /* Mobile Dark Mode */
        @media (hover: none) and (prefers-color-scheme: dark) {
            .toggle-stats-btn:active {
                background: rgba(255, 255, 255, 0.1) !important;
            }
        }

        .add-round-btn {
            display: none;
            background: transparent;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            padding: 0;
            font-size: 24px;
            font-weight: bold;
            margin: 0 0 0 10px;
            flex-shrink: 0;
            color: #28a745;
            border: none;
            line-height: 1;
            cursor: pointer;
        }
        
        .add-round-btn:hover {
            background: transparent;
            transform: scale(1.1);
            color: #218838;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .add-round-btn {
                display: inline-block;
            }
        }

        #handicapChart {
            background: var(--color-bg-primary);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            margin-bottom: 20px;
            overflow-x: auto;
        }
        
        #hcpCanvas {
            width: 100%;
            height: auto;
            max-width: 600px;
            display: block;
            margin: 0 auto;
        }
        
        @media (max-width: 768px) {
            #handicapChart {
                padding: 15px;
                margin-top: 15px;
            }
            
            #hcpCanvas {
                max-width: 100%;
                min-height: 200px;
            }
        }

        .show-all-rounds-btn {
            display: block;
            width: 100%;
            max-width: 300px;
            margin: 15px auto;
            padding: 10px 20px;
            background: transparent;
            color: var(--color-text-secondary);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 400;
            transition: all 0.2s;
            text-align: center;
        }
        
        .show-all-rounds-btn:hover {
            background: var(--color-bg-primary);
            border-color: var(--color-text-secondary);
            color: var(--color-text-primary);
            transform: translateY(-1px);
        }

        
        .rounds-hidden {
            display: none;
        }

        input[type="radio"]:checked + span {
            color: var(--color-primary);
            font-weight: 600;
        }
        
        label:has(input[type="radio"]:checked) {
            border-color: var(--color-primary) !important;
            background: var(--color-surface) !important;
        }
        
        /* Bessere Farben f√ºr aktive Radio-Buttons */
        @media (prefers-color-scheme: light) {
            label:has(input[type="radio"]:checked) {
                background: rgba(40, 167, 69, 0.1) !important;
                color: var(--color-primary);
            }
        }
        
        @media (prefers-color-scheme: dark) {
            label:has(input[type="radio"]:checked) {
                background: rgba(40, 167, 69, 0.2) !important;
            }
        }


        @media (min-width: 769px) {
            .course-info {
                white-space: pre-line;
            }
            .mobile-bullet {
                display: none; /* Desktop: kein ‚Ä¢ */
            }
        }
        
        @media (max-width: 768px) {
            .course-info {
                white-space: nowrap; /* Mobile: keine Umbr√ºche */
            }
            .mobile-bullet {
                display: inline; /* Mobile: zeige ‚Ä¢ */
            }
        }

        #hcpButtonUnderGraph {
            display: block !important;
            margin: 15px auto 0 auto;
        }

        @media (max-width: 768px) {
            #handicapChartWrapper {
                display: none !important;
            }
            
            #handicapChartWrapper.block {
                display: block !important;
            }
        }

        /* Mobile: Tausche Gesamtrunden & Offizielle f√ºr bessere Zuordnung */
        @media (max-width: 768px) {
            .stats-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
            }
            
            /* Reihenfolge √§ndern: Offizielle (2) ‚Üí Position 1, Gesamtrunden (1) ‚Üí Position 2 */
            .stat:nth-child(1) { order: 2; }  /* Gesamtrunden nach rechts */
            .stat:nth-child(2) { order: 1; }  /* Offizielle nach links */
            .stat:nth-child(3) { order: 3; }  /* Beste Runde bleibt */
            .stat:nth-child(4) { order: 4; }  /* √ò Schl√§ge bleibt */
        }


    </style>
</head>
<body tabindex="-1">
    <div id="setupScreen" class="setup-form">
        <h2>Einmalige Einrichtung</h2>
        <p style="margin-bottom: 20px;">Deine pers√∂nlichen Golf-Daten:</p>
        <input id="myName" placeholder="Dein Name" required>
        <input id="myClub" placeholder="Dein Club (optional)">
        <input id="startHcp" type="number" step="0.1" inputmode="decimal" placeholder="Aktuelles Handicap (z.B. 19.5)" required>
        <button onclick="setupComplete()">‚úÖ Einrichtung abschlie√üen</button>
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--color-border);">
            <input type="file" id="setupImportFile" accept=".json" onchange="setupImportData(event)" style="display: none;">
            <a href="#" onclick="document.getElementById('setupImportFile').click(); return false;" style="color: var(--color-text-secondary); font-size: 13px; text-decoration: none;">
                üìÅ Oder bestehende Daten importieren
            </a>
        </div>
    </div>
    
    <div id="mainApp" style="display:none;">
        <div class="container">
            <div class="sidebar">
                
                <h2>Neue Runde</h2>
                
                <!-- 9/18 L√∂cher -->
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <label style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; cursor: pointer; padding: 0 12px; background: var(--color-bg-primary); border-radius: 8px; border: 2px solid transparent; height: 46px; box-sizing: border-box;" id="roundHoles9Label">
                        <input type="radio" name="roundHoles" id="roundHoles9" value="9" style="width: auto; margin: 0;" onchange="filterCoursesByHoles()">
                        <span style="font-weight: 500;">9 L√∂cher</span>
                    </label>
                    <label style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; cursor: pointer; padding: 0 12px; background: var(--color-bg-primary); border-radius: 8px; border: 2px solid transparent; height: 46px; box-sizing: border-box;" id="roundHoles18Label">
                        <input type="radio" name="roundHoles" id="roundHoles18" value="18" checked style="width: auto; margin: 0;" onchange="filterCoursesByHoles()">
                        <span style="font-weight: 500;">18 L√∂cher</span>
                    </label>
                </div>
                
                <select id="roundCourse" style="height: 46px; margin-bottom: 5px;"></select>

                <!-- Datum + HCP-Runde Zeile -->
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <input id="roundDate" type="date" style="flex: 1; height: 46px;">
                    
                    <label style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; cursor: pointer; padding: 0 12px; background: var(--color-bg-primary); border-radius: 8px; border: 2px solid transparent; height: 46px; box-sizing: border-box;" id="roundOfficialLabel">
                        <input type="radio" name="roundOfficial" id="roundOfficial" value="official" style="width: auto; margin: 0;" onchange="resetOfficialOnCourseChange()">
                        <span style="font-weight: 500; font-size: 14px;">HCP-Runde</span>
                    </label>
                </div>
                
                <input id="roundStrokes" type="number" inputmode="numeric" placeholder="Schl√§ge eingeben" style="height: 46px; margin-bottom: 5px;">

                
                <button onclick="saveRound()">Runde speichern</button>

                
                <h2 style="margin-top: 30px;">Neuer Platz</h2>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <label style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; cursor: pointer; padding: 0 12px; background: var(--color-bg-primary); border-radius: 8px; border: 2px solid transparent; height: 46px; box-sizing: border-box;" id="courseHoles9Label">
                        <input type="radio" name="courseHoles" id="courseHoles9" value="9" style="width: auto; margin: 0;">
                        <span style="font-weight: 500;">9 L√∂cher</span>
                    </label>
                    <label style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; cursor: pointer; padding: 0 12px; background: var(--color-bg-primary); border-radius: 8px; border: 2px solid transparent; height: 46px; box-sizing: border-box;" id="courseHoles18Label">
                        <input type="radio" name="courseHoles" id="courseHoles18" value="18" checked style="width: auto; margin: 0;">
                        <span style="font-weight: 500;">18 L√∂cher</span>
                    </label>
                </div>
                <input id="courseName" placeholder="Platzname">
                <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                    <input id="coursePar" type="number" inputmode="numeric" placeholder="Par" style="flex: 1; min-width: 0; text-align: center;">
                    <input id="courseCR" type="number" step="0.1" inputmode="decimal" placeholder="CR" style="flex: 1; min-width: 0; text-align: center;">
                    <input id="courseSR" type="number" inputmode="numeric" placeholder="SR" style="flex: 1; min-width: 0; text-align: center;">
                </div>
                <button onclick="addCourse()">Platz speichern</button>

                <h2 style="margin-top: 30px;">Pl√§tze verwalten</h2>
                <div id="courseManageList" style="margin-top:15px;"></div>
                <button id="showAllCoursesBtn" class="show-all-rounds-btn" onclick="toggleAllCourses()" style="display: none; margin-top: 10px; font-size: 12px; padding: 8px;">Alle Pl√§tze anzeigen</button>
                
                <h2 style="margin-top: 30px;">üîÑ Daten-Verwaltung</h2>
                <button onclick="exportData()">üíæ Daten exportieren (JSON)</button>
                <div class="file-input-wrapper" style="margin-bottom: 0;">
                
                <input type="file" id="importFile" accept=".json" onchange="importData(event)">
                <button class="secondary" onclick="document.getElementById('importFile').click()">üìÅ Daten importieren</button>
                </div>
                
                <button class="secondary" onclick="showEditProfile()">üë§ Profil bearbeiten</button>
                <button class="danger" onclick="clearData()">üóëÔ∏è Alles l√∂schen</button>
                </div>
            
            <div class="main">
                <div style="text-align: center; margin-bottom: 30px;">
                    <h1 style="font-size: 1.2em; margin-bottom: 5px; color: var(--color-text-primary);">
                        <span id="golferNameDisplay">-</span> - <span id="golferClubDisplay">-</span>
                    </h1>
                </div>
                
                <div class="hcp-boxes">
                    <div class="hcp-box official">
                        <div class="hcp-box-label">üèÜ HCP (gewertet)</div>
                        <div class="hcp-box-value" id="officialHcp">-</div>
                    </div>
                    <div class="hcp-box unofficial">
                        <div class="hcp-box-label">üèåÔ∏è HCP (gesamt)</div>
                        <div class="hcp-box-value" id="unofficialHcp">-</div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat">
                        <div class="stat-value" id="totalRounds">0</div>
                        <div>Runden (gesamt)</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="officialRounds">0</div>
                        <div>HCP Runden ‚òÜ</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="bestRound">-</div>
                        <div>Beste Runde</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="avgStrokes">-</div>
                        <div>‚åÄ Schl√§ge</div>
                    </div>
                </div>
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h2 style="margin: 0;">Letzte Runden</h2>
                    <div style="display: flex; align-items: center;">
                        <button class="toggle-stats-btn small" onclick="toggleAdvancedStats()">
                            üìä Erweiterte Statistiken
                        </button>
                        <button class="add-round-btn" onclick="scrollToAddRound()" title="Neue Runde erfassen">
                            +
                        </button>
                    </div>
                </div>

                
                <div id="advancedStats" class="advanced-stats">
                    <h3 style="color: var(--color-primary); margin-bottom: 15px;">üìä Erweiterte Statistiken</h3>
                    
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: var(--color-text-secondary); font-size: 0.9em; margin-bottom: 10px;">ALLGEMEINE STATISTIK</h4>
                        <div id="generalStats"></div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: var(--color-text-secondary); font-size: 0.9em; margin-bottom: 10px;">PLATZ-STATISTIK</h4>
                        <div id="courseStats"></div>
                    </div>
                    
                    <div>
                        <h4 style="color: var(--color-text-secondary); font-size: 0.9em; margin-bottom: 10px;">TREND-ANALYSE</h4>
                        <div id="trendStats"></div>
                    </div>
                </div>
                
                <!-- Graph + Button Wrapper -->
                <div id="handicapChartWrapper" style="display: none; text-align: center; margin-bottom: 25px;">
                    <canvas id="hcpCanvas"></canvas>
                    <div style="margin-top:10px;font-size:14px;color:var(--color-text-secondary);">
                        Handicap-Entwicklung (letzte 10 Runden)
                    </div>
                    <button id="hcpButtonUnderGraph" class="toggle-stats-btn small" onclick="showHandicapCalculation()" style="margin-top: 10px;">
                        HCP-Berechnung anzeigen
                    </button>
                </div>


                <div class="round-list" id="roundList"></div>
                
                <button id="showAllRoundsBtn" class="show-all-rounds-btn" onclick="toggleAllRounds()" style="display: none;">
                    üìã Alle Runden anzeigen
                </button>

                </div>
            </div>
        </div>
    
    <script>
        let myGolfer = null;
        let courses = [];
        
        function init() {
            myGolfer = null;
            courses = []; 
            loadData();
            checkSetup();
        }

        function setupComplete() {
            const name = document.getElementById('myName').value.trim();
            const club = document.getElementById('myClub').value.trim();
            const startHcpStr = document.getElementById('startHcp').value; // Hole den String zuerst
            
            // Trimmen und Komma durch Punkt ersetzen (wichtig f√ºr deutsche Eingabe)
            const startHcp = parseFloat(startHcpStr.replace(',', '.'));
        
            // Detaillierte Fehlerpr√ºfung mit Alert
            if (!name) {
                return alert('Bitte einen Namen eingeben!');
            }
            
            if (isNaN(startHcp)) {
                return alert('Bitte ein g√ºltiges Handicap eingeben (z.B. 19.5 oder 19,5)!');
            }
            
            if (startHcp < -5 || startHcp > 54) {
                return alert('Handicap muss zwischen -5 und 54 liegen!');
            }
        
            if (!myGolfer) {
                // Falls myGolfer noch null ist (Sicherheitsnetz)
                myGolfer = {};
            }
        
            // Profil korrekt erstellen
            myGolfer.id = 'me';
            myGolfer.name = name;
            myGolfer.club = club || '';
            myGolfer.handicapIndex = startHcp;
            myGolfer.lowestHandicapIndex = startHcp;
            myGolfer.unofficialHandicap = startHcp;
            myGolfer.rounds = [];
            myGolfer.startHcp = startHcp;
            myGolfer.created = new Date().toISOString();
        
            // Speichern
            localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
            
            // UI Update ausl√∂sen
            checkSetup();
        }

        function checkSetup() {
            try {
                const stored = localStorage.getItem('myGolfer');
                myGolfer = stored ? JSON.parse(stored) : null;
            } catch (err) {
                console.error('Fehler beim Laden der Daten:', err);
                myGolfer = null; // Bei Fehler: Neu starten
            }
            
            if (!myGolfer) {
                document.getElementById('setupScreen').style.display = 'block';
                document.getElementById('mainApp').style.display = 'none';
            } else {
                document.getElementById('setupScreen').style.display = 'none';
                document.getElementById('mainApp').style.display = 'block';
                updateUI();
                document.getElementById('roundDate').valueAsDate = new Date();
            }
        }

        
        function updateUI() {
            if (!myGolfer) return;
            
            document.getElementById('golferNameDisplay').textContent = myGolfer.name;
            document.getElementById('golferClubDisplay').textContent = myGolfer.club || 'Unabh√§ngiger Golfer';
            
            const rounds = myGolfer.rounds || [];
            const officialRounds = rounds.filter(r => r.official !== false);
            
            document.getElementById('totalRounds').textContent = rounds.length;
            document.getElementById('officialRounds').textContent = officialRounds.length;
            document.getElementById('officialHcp').textContent = myGolfer.handicapIndex.toFixed(1);
            document.getElementById('unofficialHcp').textContent = (myGolfer.unofficialHandicap || myGolfer.handicapIndex).toFixed(1);
            
            if (rounds.length > 0) {
                const strokes18 = rounds.filter(r => r.holes === 18).map(r => r.strokes);
                const bestStroke = strokes18.length > 0 ? Math.min(...strokes18) : Math.min(...rounds.map(r => r.strokes));
                document.getElementById('bestRound').textContent = bestStroke;
                document.getElementById('avgStrokes').textContent = Math.round(rounds.map(r => r.strokes).reduce((a,b) => a + b, 0) / rounds.length);
            } else {
                document.getElementById('bestRound').textContent = '-';
                document.getElementById('avgStrokes').textContent = '-';
            }
            
                renderCourses();
                renderRounds();
                const chartWrapper = document.getElementById('handicapChartWrapper');
                if (rounds.length >= 2) {
                    chartWrapper.style.display = 'block';
                    chartWrapper.classList.add('block');  // Mobile Override
                    renderChart();
                } else {
                    chartWrapper.style.display = 'none';
                    chartWrapper.classList.remove('block');
                }


        }
        
        function loadData() {
            try {
                const data = localStorage.getItem('courses');
                courses = data ? JSON.parse(data) : [];
            } catch (err) {
                console.error('Fehler beim Laden der Pl√§tze:', err);
                courses = []; // Bei Fehler: Leeres Array
            }
        }
        
        function saveCourses() {
            localStorage.setItem('courses', JSON.stringify(courses));
        }

        function calculateCourseHandicap(handicapIndex, slopeRating, courseRating, par) {
            // WHS-Formel: Course Handicap = HCP Index √ó (SR / 113) + (CR - Par)
            return Math.round(handicapIndex * (slopeRating / 113) + (courseRating - par));
        }
        
        function renderCourses() {
            filterCoursesByHoles();
            const manageList = document.getElementById('courseManageList');
            if (manageList) {
            if (courses.length === 0) {
                        manageList.innerHTML = '<div style="text-align:center;color:var(--color-text-secondary);padding:20px;font-size:14px;">Keine Pl√§tze angelegt</div>';
                        document.getElementById('showAllCoursesBtn').style.display = 'none';
                    } else {
                    // Button nur anzeigen wenn mehr als 3 Pl√§tze
                    const showAllCoursesBtn = document.getElementById('showAllCoursesBtn');
                    const showAll = window.showAllCourses || false;
                    if (courses.length > 3) {
                        showAllCoursesBtn.style.display = 'block';
                        showAllCoursesBtn.textContent = showAll ? 'Weniger anzeigen' : 'Alle Pl√§tze anzeigen';
                    } else {
                        showAllCoursesBtn.style.display = 'none';
                    }
                    // Sortiere nach Neuheit (neueste zuerst) f√ºr VERWALTUNG
                    const sortedCourses = [...courses].sort((a, b) => b.id - a.id);
                    // Zeige nur 3 oder alle
                    const displayCourses = (showAll || sortedCourses.length <= 3) ? sortedCourses : sortedCourses.slice(0, 3);
                manageList.innerHTML = displayCourses.map(c => `
                    <div style="display:flex;justify-content:space-between;align-items:center;padding:10px;background:var(--color-bg-primary);margin-bottom:8px;border-radius:8px;">
                        <div style="flex:1;">
                            <div style="font-weight:600;font-size:14px;">${c.name}</div>
                            <div class="course-info" style="font-size:12px;color:var(--color-text-secondary);">CR ${c.cr.toFixed(1)} ‚Ä¢ SR ${c.sr} ‚Ä¢ Par ${c.par || (c.holes === 9 ? 36 : 72)}
                            <span class="mobile-bullet"> ‚Ä¢ </span>${c.holes || 18} L√∂cher</div>
                                
                            </div>
                        <div style="display:flex;gap:6px;">
                            <button onclick="editCourse('${c.id}')" class="small" style="background:var(--color-border);color:var(--color-text-secondary);" title="Bearbeiten">‚úèÔ∏è</button>
                            <button onclick="deleteCourse('${c.id}')" class="small" style="background:var(--color-border);color:var(--color-text-secondary);" title="L√∂schen">üóëÔ∏è</button>
                        </div>
                    </div>
                `).join('');
                }
            }
        }

         function filterCoursesByHoles() {
            const selectedHoles = parseInt(document.querySelector('input[name="roundHoles"]:checked').value);
            const select = document.getElementById('roundCourse');
        
            // Z√§hle, wie oft jeder Platz gespielt wurde
            const courseCounts = {};
            if (myGolfer && myGolfer.rounds) {
                myGolfer.rounds.forEach(round => {
                    // FIX: Ber√ºcksichtige auch die Lochzahl beim Finden des Platzes
                    const course = courses.find(c => c.name === round.course && c.holes === round.holes);
                    if (course) {
                        courseCounts[course.id] = (courseCounts[course.id] || 0) + 1;
                    }
                });
            }
            
            // Filtere Pl√§tze nach Lochzahl
            const filteredCourses = courses.filter(c => c.holes === selectedHoles);
            
            if (filteredCourses.length === 0) {
                select.innerHTML = `<option value="">Kein ${selectedHoles}-Loch-Platz angelegt!</option>`;
                return;
            }
            
            // Sortiere nach H√§ufigkeit
            const sortedCourses = [...filteredCourses].sort((a, b) => {
                const countA = courseCounts[a.id] || 0;
                const countB = courseCounts[b.id] || 0;
                return countB - countA;
            });
            
            select.innerHTML = sortedCourses.map(c => {
                const playCount = courseCounts[c.id] || 0;
                const countText = playCount > 0 ? ` ‚Ä¢ ${playCount}x` : '';
                
                // Berechne Spielvorgabe
                const par = c.par || (c.holes === 9 ? 36 : 72);
                const courseHcp = calculateCourseHandicap(myGolfer.handicapIndex, c.sr, c.cr, par);
                
                return `<option value="${c.id}">${c.name} ‚Ä¢ Vorgabe: ${courseHcp}${countText}</option>`;
            }).join('');

             // Update placeholder wenn Kurs ausgew√§hlt wird
            document.getElementById('roundCourse').addEventListener('change', updateStrokesPlaceholder);
            updateStrokesPlaceholder(); // Initialer Aufruf

            }

        function updateStrokesPlaceholder() {
                const courseId = document.getElementById('roundCourse').value;
                const course = courses.find(c => c.id === courseId);
                const strokesInput = document.getElementById('roundStrokes');
                
                if (course) {
                    const par = course.par || (course.holes === 9 ? 36 : 72);
                    strokesInput.placeholder = `Schl√§ge eingeben ‚Ä¢ Par ${par}`;
                } else {
                    strokesInput.placeholder = 'Schl√§ge eingeben';
                }
            }


        function validateRoundData(strokes, holes, date) {
            const errors = [];
            
            const minStrokes = holes === 9 ? 25 : 50;
            const maxStrokes = holes === 9 ? 80 : 160;
            
            if (!strokes || strokes < minStrokes || strokes > maxStrokes) {
                errors.push(`Schl√§ge m√ºssen zwischen ${minStrokes} und ${maxStrokes} liegen`);
            }
            
            if (!date || new Date(date) > new Date()) {
                errors.push('Datum darf nicht in der Zukunft liegen');
            }
            
            // Pr√ºfe ob Datum zu weit in der Vergangenheit (z.B. √§lter als 3 Jahre)
            const threeYearsAgo = new Date();
            threeYearsAgo.setFullYear(threeYearsAgo.getFullYear() - 3);
            if (date && new Date(date) < threeYearsAgo) {
                errors.push('Datum liegt mehr als 3 Jahre zur√ºck - bitte pr√ºfen');
            }
            
            return errors;
        }

        function resetOfficialOnCourseChange() {
            // Speichere die Funktion f√ºr sp√§ter
            if (!window.courseChangeListenerAdded) {
                document.getElementById('roundCourse').addEventListener('change', function() {
                    document.getElementById('roundOfficial').checked = false;
                });
                window.courseChangeListenerAdded = true;
            }
        }

        
        function saveRound() {
            const courseId = document.getElementById('roundCourse').value;
            const course = courses.find(c => c.id === courseId);
            
            if (!course) {
                return alert('Bitte zuerst einen Platz anlegen oder ausw√§hlen!');
            }
            
            const strokes = parseInt(document.getElementById('roundStrokes').value);
            const holes = parseInt(document.querySelector('input[name="roundHoles"]:checked').value);
            const date = document.getElementById('roundDate').value;
            
            const validationErrors = validateRoundData(strokes, holes, date);
            if (validationErrors.length > 0) {
                return alert('‚ùå Eingabefehler:\n\n' + validationErrors.join('\n'));
            }

            
            // WHS 2024: Korrekte 9-Loch Berechnung
            let scoreDifferential;
            let cr, sr;
            
            if (holes === 9) {
                // Verwende 9-Loch CR und SR (NICHT halbiert!)
                cr = course.cr;
                sr = course.sr;
                
                // 1. Berechne 9-Loch Score Differential (gespielte 9 L√∂cher)
                const sd_9_played = ((strokes - cr) * (113 / sr));
                
                // 2. Berechne Expected Score Differential (nicht-gespielte 9 L√∂cher)
                // Formel: ((HCPI √ó 1.04) + 2.4) / 2
                const currentHCPI = myGolfer.handicapIndex;
                const sd_9_expected = ((currentHCPI * 1.04) + 2.4) / 2;
                
                // 3. Addiere beide f√ºr 18-Loch Score Differential
                scoreDifferential = (sd_9_played + sd_9_expected).toFixed(1);
                
            } else {
                // 18-Loch: Standard-Berechnung
                cr = course.cr;
                sr = course.sr;
                scoreDifferential = ((strokes - cr) * (113 / sr)).toFixed(1);
            }
            
            const isOfficial = document.getElementById('roundOfficial').checked;
            
            const round = {
                id: Date.now().toString(),
                date: date,
                course: course.name,
                holes: holes,
                strokes: strokes,
                cr: cr.toFixed(1),
                sr: sr.toFixed(0),
                scoreDifferential: parseFloat(scoreDifferential),
                playingHcp: myGolfer.handicapIndex,
                official: isOfficial
            };
            
            myGolfer.rounds.push(round);
            
            updateMyHandicap();
            updateUnofficialHandicap();
    
            // WHS: Exceptional Score Reduction (ESR) - NACH der normalen Berechnung
            const sdDiff = round.playingHcp - parseFloat(scoreDifferential);
            if (isOfficial && sdDiff >= 10.0) {
                myGolfer.handicapIndex = Math.max(-5.0, myGolfer.handicapIndex - 2.0);
                myGolfer.lowestHandicapIndex = Math.min(myGolfer.lowestHandicapIndex, myGolfer.handicapIndex);
                alert('üèÜ Exceptional Score! Dein Handicap wurde zus√§tzlich um -2.0 reduziert!');
            } else if (isOfficial && sdDiff >= 7.0) {
                myGolfer.handicapIndex = Math.max(-5.0, myGolfer.handicapIndex - 1.0);
                myGolfer.lowestHandicapIndex = Math.min(myGolfer.lowestHandicapIndex, myGolfer.handicapIndex);
                alert('üèÜ Exceptional Score! Dein Handicap wurde zus√§tzlich um -1.0 reduziert!');
            }
            
            localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
            
            if (myGolfer.rounds.length % 5 === 0) {
                setTimeout(() => {
                    if (confirm(`Du hast ${myGolfer.rounds.length} Runden erfasst! Automatisches Backup jetzt erstellen?`)) {
                        exportData();
                    }
                }, 500);
            }
            
            updateUI();
            
            document.getElementById('roundStrokes').value = '';
            document.getElementById('roundOfficial').checked = false;
            
            alert(`Runde gespeichert!\nDifferential: ${round.scoreDifferential}\n${isOfficial ? 'Offizielles' : 'Inoffizielles'} HCP: ${myGolfer[isOfficial ? 'handicapIndex' : 'unofficialHandicap'].toFixed(1)}`);
        }
        
        function updateMyHandicap() {
            const officialRounds = myGolfer.rounds
                .filter(r => r.official !== false)
                .slice(-20)
                .map(r => ({ id: r.id, sd: r.scoreDifferential }))
                .sort((a, b) => a.sd - b.sd);
        
            if (officialRounds.length === 0) {
                myGolfer.handicapIndex = myGolfer.startHcp;
                return;
            }
        
            const count = officialRounds.length;

            // WHS-Regel: Bei weniger als 3 Runden wird Start-Handicap verwendet
            if (count < 3) {
                myGolfer.handicapIndex = myGolfer.startHcp;
                myGolfer.countedRoundIds = [];
                return;
            }

            const { numCounted, adjustment } = getWHSParameters(count);
                    
            const bestRounds = officialRounds.slice(0, numCounted);
            let newHcp = bestRounds.reduce((a, b) => a + b.sd, 0) / numCounted;
            
            // Soft Cap: lowestHCP + 3
            const lowestHcp = (typeof myGolfer.lowestHandicapIndex === 'number') ? myGolfer.lowestHandicapIndex : myGolfer.startHcp;
            const softCapLimit = lowestHcp + 3.0;
            newHcp = Math.min(newHcp, softCapLimit);
            
            // Anpassung (Bonus) anwenden
            newHcp += adjustment;
        
            myGolfer.handicapIndex = Math.round(newHcp * 10) / 10;

            // WHS: Hard Cap - HCP darf nie mehr als 5.0 √ºber dem besten Wert liegen
            if (typeof myGolfer.lowestHandicapIndex !== 'number') {
                myGolfer.lowestHandicapIndex = myGolfer.handicapIndex;
            } else {
                myGolfer.lowestHandicapIndex = Math.min(myGolfer.lowestHandicapIndex, myGolfer.handicapIndex);
            }
            const hardCapLimit = myGolfer.lowestHandicapIndex + 5.0;
            if (myGolfer.handicapIndex > hardCapLimit) {
                myGolfer.handicapIndex = hardCapLimit;
            }

            // Speichere die IDs der gewerteten Runden f√ºr Stern-Markierung
            myGolfer.countedRoundIds = bestRounds.map(r => r.id);
        }

    
        function updateUnofficialHandicap() {
            const allRounds = myGolfer.rounds
                .slice(-20)
                .map(r => ({ id: r.id, sd: r.scoreDifferential }))
                .sort((a, b) => a.sd - b.sd);
        
            if (allRounds.length === 0) {
                myGolfer.unofficialHandicap = myGolfer.startHcp;
                return;
            }
        
            const count = allRounds.length;
        
            // WHS-Regel: Bei weniger als 3 Runden wird Start-Handicap verwendet
            if (count < 3) {
                myGolfer.unofficialHandicap = myGolfer.startHcp;
                return;
            }
        
            // Gleiche WHS-Parameter wie beim offiziellen HCP
            const { numCounted, adjustment } = getWHSParameters(count);
            const bestRounds = allRounds.slice(0, numCounted);
            let newHcp = bestRounds.reduce((a, b) => a + b.sd, 0) / numCounted;
        
            // Soft Cap: beste SD + 3
            const lowestHcp = (typeof myGolfer.lowestHandicapIndex === 'number') ? myGolfer.lowestHandicapIndex : myGolfer.startHcp;
            newHcp = Math.min(newHcp, lowestHcp + 3.0);
        
            // Anpassung (Bonus) anwenden
            newHcp += adjustment;
        
            myGolfer.unofficialHandicap = Math.round(newHcp * 10) / 10;

            // WHS: Hard Cap f√ºr inoffizielles HCP
            if (typeof myGolfer.lowestHandicapIndex !== 'number') {
                        myGolfer.lowestHandicapIndex = myGolfer.unofficialHandicap;
                    }
            const hardCapLimit = myGolfer.lowestHandicapIndex + 5.0;
            if (myGolfer.unofficialHandicap > hardCapLimit) {
                myGolfer.unofficialHandicap = hardCapLimit;
            }

        }
        
        function getWHSParameters(count) {
            let numCounted = 1;
            let adjustment = 0;
    
            if (count >= 3 && count <= 4) {
               numCounted = 1;
               adjustment = count === 3 ? -2.0 : -1.0;
          } else if (count === 5) {
              numCounted = 1;
              adjustment = 0;
          } else if (count === 6) {
              numCounted = 2;
              adjustment = -1.0;
          } else if (count >= 7 && count <= 8) {
              numCounted = 2;
              adjustment = 0;
           } else if (count >= 9 && count <= 11) {
              numCounted = 3;
              adjustment = 0;
          } else if (count >= 12 && count <= 14) {
              numCounted = 4;
              adjustment = 0;
           } else if (count >= 15 && count <= 16) {
               numCounted = 5;
              adjustment = 0;
           } else if (count >= 17 && count <= 18) {
               numCounted = 6;
               adjustment = 0;
            } else if (count === 19) {
                numCounted = 7;
                adjustment = 0;
            } else if (count >= 20) {
                numCounted = 8;
                adjustment = 0;
            }
            
           return { numCounted, adjustment };
        }
        
        function toggleAdvancedStats() {
            const stats = document.getElementById('advancedStats');
            const btn = document.querySelector('.toggle-stats-btn');
            const isVisible = stats.style.display === 'block';
    
            // NEU: Statistiken berechnen bevor sie angezeigt werden
            if (!isVisible) {
              renderAdvancedStats();
            }
    
             stats.style.display = isVisible ? 'none' : 'block';
             btn.textContent = isVisible ? 'üìä Erweiterte Statistiken' : '‚úñ Statistiken ausblenden';
    
             // Mobile Force Blur
                if (window.matchMedia('(hover: none)').matches) {
                   btn.blur();
                  document.body.focus();
                  // Trigger Repaint
                  requestAnimationFrame(() => {
                      btn.style.pointerEvents = 'none';
                     setTimeout(() => {
                         btn.style.pointerEvents = '';
                     }, 50);
                  });
             }
        }
     
        function renderAdvancedStats() {
            const rounds = myGolfer.rounds || [];
            if (rounds.length === 0) return;
            
            const generalStats = document.getElementById('generalStats');
            const courseStats = document.getElementById('courseStats');
            const trendStats = document.getElementById('trendStats');
            
            const rounds18 = rounds.filter(r => r.holes === 18);
            const rounds9 = rounds.filter(r => r.holes === 9);
            const last10 = rounds.slice(-10);
            const last5 = rounds.slice(-5);
            
            const avgLast10 = last10.length > 0 ? (last10.map(r => r.strokes).reduce((a,b) => a + b, 0) / last10.length).toFixed(1) : '-';
            const avgLast5 = last5.length > 0 ? (last5.map(r => r.strokes).reduce((a,b) => a + b, 0) / last5.length).toFixed(1) : '-';
            
            const sdValues = rounds.map(r => r.scoreDifferential);
            const bestSD = Math.min(...sdValues).toFixed(1);
            const worstSD = Math.max(...sdValues).toFixed(1);
            const avgSD = (sdValues.reduce((a,b) => a + b, 0) / sdValues.length).toFixed(1);
            
            const underPar = rounds.filter(r => r.scoreDifferential < r.playingHcp).length;
            const overPar = rounds.filter(r => r.scoreDifferential > r.playingHcp + 3).length;
            
            generalStats.innerHTML = `
                <div class="stat-row">
                    <span class="stat-label">‚åÄ Score Differential</span>
                    <span class="stat-data">${avgSD}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Bester Score Diff.</span>
                    <span class="stat-data">${bestSD}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Schlechtester Score Diff.</span>
                    <span class="stat-data">${worstSD}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">18-Loch Runden</span>
                    <span class="stat-data">${rounds18.length}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">9-Loch Runden</span>
                    <span class="stat-data">${rounds9.length}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Unter HCP gespielt</span>
                    <span class="stat-data">${underPar} (${((underPar/rounds.length)*100).toFixed(0)}%)</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Stark √ºber HCP</span>
                    <span class="stat-data">${overPar} (${((overPar/rounds.length)*100).toFixed(0)}%)</span>
                </div>
            `;
            
 const coursesPlayed = {};
rounds.forEach(r => {
    // Gruppiere nach Platzname + Lochzahl
    const key = `${r.course}-${r.holes}L`;
    if (!coursesPlayed[key]) {
        coursesPlayed[key] = { 
            name: r.course,
            holes: r.holes,
            count: 0, 
            strokes: [], 
            scoreDiffs: [],
            rounds: []
        };
    }
    coursesPlayed[key].count++;
    coursesPlayed[key].strokes.push(r.strokes);
    coursesPlayed[key].scoreDiffs.push(r.scoreDifferential);
    coursesPlayed[key].rounds.push(r);
});
            
 const courseStatsHtml = Object.entries(coursesPlayed)
    .sort((a,b) => b[1].count - a[1].count)
    .slice(0, 5)
    .map(([key, data]) => {
        // Berechne den besten SD
        const bestSD = Math.min(...data.scoreDiffs);
        
        // Finde die beste Runde aus den gespeicherten Runden
        const bestRound = data.rounds.find(r => r.scoreDifferential === bestSD);
        
        // Anzeigename mit Lochzahl
        const displayName = `${data.name} (${data.holes}L)`;

        const avgStrokes = (data.strokes.reduce((a,b) => a + b, 0) / data.count).toFixed(1);
        const avgSD = (data.scoreDiffs.reduce((a,b) => a + b, 0) / data.count).toFixed(1);
        
        // Par-Wert aus dem Kurs holen (mit korrekter Lochzahl)
        const courseInfo = courses.find(c => c.name === data.name && c.holes === data.holes);
        const coursePar = courseInfo ? (courseInfo.par || (data.holes === 9 ? 36 : 72)) : (data.holes === 9 ? 36 : 72);

        // Beste Runde relativ zu Par berechnen
        const bestStrokes = Math.min(...data.strokes);
        const bestToPar = bestStrokes - coursePar;
        const bestToParText = bestToPar > 0 ? `+${bestToPar}` : bestToPar.toString();

        return `
            <div class="course-stats-item">
                <div style="font-weight: 600; margin-bottom: 5px;">${displayName}</div>
                <div style="font-size: 0.85em; color: var(--color-text-secondary);">
                    ${data.count}x gespielt ‚Ä¢ ‚åÄ ${avgStrokes} Schl√§ge ‚Ä¢ ‚åÄ SD ${avgSD}<br>
                    <strong>Beste:</strong> ${bestStrokes} Schl√§ge (${bestToParText} zum Par) ‚Ä¢ SD: ${bestSD.toFixed(1)}
                </div>
            </div>
        `;
    }).join('');
                    
            courseStats.innerHTML = courseStatsHtml || '<div style="text-align:center;color:var(--color-text-secondary);padding:20px;">Keine Platzdaten</div>';
            
            const hcpStart = myGolfer.startHcp;
            const hcpCurrent = myGolfer.handicapIndex;
            const hcpChange = (hcpCurrent - hcpStart).toFixed(1);
            const hcpChangePercent = hcpStart !== 0 ? ((hcpChange / hcpStart) * 100).toFixed(1) : '0.0';
            
            const trendEmoji = hcpChange < 0 ? 'üìà' : hcpChange > 0 ? 'üìâ' : '‚û°Ô∏è';
            const trendText = hcpChange < 0 ? 'Verbesserung' : hcpChange > 0 ? 'Verschlechterung' : 'Stabil';

            // Berechne HCP vor 30 Tagen
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            
            const rounds30DaysAgo = myGolfer.rounds.filter(r => new Date(r.date) <= thirtyDaysAgo);
            let hcp30DaysAgo = myGolfer.startHcp;
            
            if (rounds30DaysAgo.length >= 3) {
                const officialRounds30 = rounds30DaysAgo
                    .filter(r => r.official !== false)
                    .slice(-20)
                    .map(r => ({ id: r.id, sd: r.scoreDifferential }))
                    .sort((a, b) => a.sd - b.sd);
                
            if (officialRounds30.length >= 3) {
                            const { numCounted, adjustment } = getWHSParameters(officialRounds30.length);
                            const bestRounds = officialRounds30.slice(0, numCounted);
                            let avgHcp = bestRounds.reduce((a, b) => a + b.sd, 0) / numCounted;
                            const lowestHcp = (typeof myGolfer.lowestHandicapIndex === 'number') ? myGolfer.lowestHandicapIndex : myGolfer.startHcp;
                            avgHcp = Math.min(avgHcp, lowestHcp + 3.0);
                            avgHcp += adjustment;
                            hcp30DaysAgo = Math.round(avgHcp * 10) / 10;
                    }
            }
            
            const monthChange = (myGolfer.handicapIndex - hcp30DaysAgo).toFixed(1);
            const monthEmoji = monthChange < 0 ? 'üìà' : monthChange > 0 ? 'üìâ' : '‚û°Ô∏è';
            const monthText = monthChange < 0 ? 'Verbesserung' : monthChange > 0 ? 'Verschlechterung' : 'Stabil';

            
            trendStats.innerHTML = `
                <div class="stat-row">
                    <span class="stat-label">Start-Handicap</span>
                    <span class="stat-data">${hcpStart.toFixed(1)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìÖ Letzter Monat</span>
                    <span class="stat-data" style="color: ${monthChange < 0 ? 'var(--color-primary)' : monthChange > 0 ? 'var(--color-danger)' : 'var(--color-warning)'}">
                        ${monthEmoji} ${monthChange > 0 ? '+' : ''}${monthChange} (${monthText})
                    </span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Aktuelles Handicap</span>
                    <span class="stat-data">${hcpCurrent.toFixed(1)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">${trendEmoji} Entwicklung</span>
                    <span class="stat-data" style="color: ${hcpChange < 0 ? 'var(--color-primary)' : hcpChange > 0 ? 'var(--color-danger)' : 'var(--color-warning)'}">
                        ${hcpChange > 0 ? '+' : ''}${hcpChange} (${hcpChangePercent > 0 ? '+' : ''}${hcpChangePercent}%)
                    </span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Trend</span>
                    <span class="stat-data">${trendText}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚åÄ Schl√§ge (letzte 10)</span>
                    <span class="stat-data">${avgLast10}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚åÄ Schl√§ge (letzte 5)</span>
                    <span class="stat-data">${avgLast5}</span>
                </div>
            `;
        }
        
        function renderRounds() {
            const rounds = [...myGolfer.rounds]
            .sort((a, b) => new Date(b.date) - new Date(a.date));
            
            const container = document.getElementById('roundList');
            
            if (rounds.length === 0) {
                container.innerHTML = `<div style="text-align:center;color:var(--color-text-secondary);padding:40px;">Noch keine Runden erfasst</div>`;
                document.getElementById('showAllRoundsBtn').style.display = 'none';
                return;
            }
        
            // Hole die IDs der gewerteten Runden aus dem Golfer-Objekt
            const countedRoundIds = myGolfer.countedRoundIds || [];
            
            // Zeige Button nur wenn mehr als 5 Runden vorhanden
            const showAllBtn = document.getElementById('showAllRoundsBtn');
            const showAll = window.showAllRounds || false;
            
            if (rounds.length > 5) {
                showAllBtn.style.display = 'block';
                showAllBtn.textContent = showAll ? 'üìã Weniger anzeigen' : 'üìã Alle Runden anzeigen';
            } else {
                showAllBtn.style.display = 'none';
            }
            
            // Entscheide wie viele Runden angezeigt werden
            const displayRounds = (showAll || rounds.length <= 5) ? rounds : rounds.slice(0, 5);
        
            container.innerHTML = displayRounds.map((r, index) => {
                // Platz finden f√ºr Par-Wert
                const course = courses.find(c => c.name === r.course && c.holes === r.holes);
                const coursePar = course ? course.par : (r.holes === 9 ? 36 : 72);
                
                // Differenz zu Par berechnen
                const diffToPar = r.strokes - coursePar;
                const diffToParText = diffToPar > 0 ? `+${diffToPar}` : `${diffToPar}`;
                
                // Differenz zur Spielvorgabe (Hauptwert) - NEUE BERECHNUNG
                const playingHcp = course
                ? calculateCourseHandicap(r.playingHcp, parseInt(r.sr), parseFloat(r.cr), coursePar)
                : Math.round(r.playingHcp);
                
                const allowedStrokes = coursePar + playingHcp;
                const diffToVorgabe = r.strokes - allowedStrokes;
                const diffToVorgabeText = diffToVorgabe > 0 ? `+${diffToVorgabe}` : `${diffToVorgabe}`;
                
                const color = diffToVorgabe < 0 ? 'var(--color-primary)'
                    : diffToVorgabe > 3 ? 'var(--color-danger)'
                    : 'var(--color-warning)';

            
                const isCounted = countedRoundIds.includes(r.id);
                const officialBadge = isCounted ? '  ‚òÜ' : '';
                const officialLabel = r.official !== false ? 'Offiziell' : 'Inoffiziell';
            
                return `
                    <div class="round-item">
                        <div style="flex: 1;">
                            <div style="font-size: 13px; color: var(--color-text-secondary);">${r.date} ‚Ä¢ ${r.holes}L${officialBadge}</div>
                            <div style="font-weight: 600; font-size: 16px; margin: 2px 0;">${r.course}</div>
                            <div style="font-size: 13px; color: var(--color-text-secondary);">${r.strokes} Schl√§ge ‚Ä¢ ${officialLabel}</div>
                        </div>
                        <div style="text-align: right; display: flex; align-items: center; gap: 10px;">
                            <div>
                                    <div style="font-size: 20px; font-weight: bold; color: ${color};">
                                        ${diffToVorgabeText} <span style="font-size: 11px; font-weight: 400; color: var(--color-text-secondary);">Netto</span>
                                    </div>
                                <div style="font-size: 12px; color: var(--color-text-secondary);">
                                    ${diffToParText} zu Par
                                </div>
                            </div>
                            <button onclick="editRound('${r.id}')" class="small" style="background:var(--color-border);color:var(--color-text-secondary);" title="Bearbeiten">‚úèÔ∏è</button>
                            <button onclick="deleteRound('${r.id}')" class="small" style="background:var(--color-border);color:var(--color-text-secondary);" title="Runde l√∂schen">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleAllRounds() {
            window.showAllRounds = !window.showAllRounds;
            renderRounds();
            
            // Scroll sanft zum Button wenn "weniger anzeigen" geklickt wurde
            if (!window.showAllRounds) {
                const btn = document.getElementById('showAllRoundsBtn');
                if (btn) {
                    btn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        function toggleAllCourses() {
            window.showAllCourses = !window.showAllCourses;
            renderCourses();
        }

        function editRound(roundId) {
            const round = myGolfer.rounds.find(r => r.id === roundId);
            if (!round) return;
        
            const newStrokes = prompt('Schl√§ge √§ndern:', round.strokes);
            if (newStrokes === null) return;
        
            const newDate = prompt('Datum √§ndern (YYYY-MM-DD):', round.date);
            if (newDate === null) return;
        
            const strokes = parseInt(newStrokes);
            if (isNaN(strokes) || strokes < 18) {
                return alert('Ung√ºltige Schlagzahl!');
            }
        
            // Finde den Platz f√ºr Neuberechnung
            const course = courses.find(c => c.name === round.course && c.holes === round.holes);
            
            round.strokes = strokes;
            round.date = newDate;
            
            // Score Differential neu berechnen
            if (course) {
                if (round.holes === 9) {
                    const sd_9_played = ((strokes - course.cr) * (113 / course.sr));
                    const sd_9_expected = ((myGolfer.handicapIndex * 1.04) + 2.4) / 2;
                    round.scoreDifferential = parseFloat((sd_9_played + sd_9_expected).toFixed(1));
                } else {
                    round.scoreDifferential = parseFloat(((strokes - course.cr) * (113 / course.sr)).toFixed(1));
                }
            }
        
            updateMyHandicap();
            updateUnofficialHandicap();
            localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
            updateUI();
            alert('‚úÖ Runde aktualisiert!');
        }

        function deleteRound(roundId) {
            if (!confirm('Diese Runde wirklich l√∂schen?\n\nDein Handicap wird neu berechnet.')) return;
            
            myGolfer.rounds = myGolfer.rounds.filter(r => r.id !== roundId);
            updateMyHandicap();
            updateUnofficialHandicap();
            localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
            updateUI();
            alert('‚úÖ Runde gel√∂scht und Handicap neu berechnet!');
        }
        
        function renderChart() {
            const rounds = myGolfer.rounds.slice(-10).sort((a, b) => new Date(a.date) - new Date(b.date));
            
            if (rounds.length < 2) return;
            
            const canvas = document.getElementById('hcpCanvas');
            const ctx = canvas.getContext('2d');
            
            // Responsive Canvas-Gr√∂√üe mit HiDPI-Unterst√ºtzung
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 40;
            const isMobile = window.innerWidth <= 768;
            const dpr = window.devicePixelRatio || 1;

            // CSS-Gr√∂√üe setzen
            canvas.style.width = Math.min(containerWidth, 600) + 'px';
            canvas.style.height = (isMobile ? 250 : 300) + 'px';

            // Mobile: Leicht kleinere interne Gr√∂√üe f√ºr bessere Performance
            const scaleFactor = isMobile ? 0.8 : 1;
            canvas.width = Math.min(containerWidth, 600) * dpr * scaleFactor;
            canvas.height = (isMobile ? 250 : 300) * dpr * scaleFactor;

            const width = canvas.width;
            const height = canvas.height;
    
            // CSS-Koordinaten f√ºr Zeichenbefehle (nach ctx.scale)
            const cssW = width / (dpr * scaleFactor);
            const cssH = height / (dpr * scaleFactor);

            // Skalierung f√ºr HiDPI
            ctx.scale(dpr * scaleFactor, dpr * scaleFactor);
            
            // Padding und Chart-Gr√∂√üe f√ºr HiDPI anpassen
            const padding = { left: 50, right: 30, top: 30, bottom: 40 };
            const chartWidth = (width / (dpr * scaleFactor)) - padding.left - padding.right;
            const chartHeight = (height / (dpr * scaleFactor)) - padding.top - padding.bottom;

            // Sch√§rfere Linien und Text f√ºr HiDPI
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Sammle HISTORISCHE HCP-Werte aus den Runden
            const unofficialHistory = [];
            const officialHistory = [];
            
            for (let i = 0; i < rounds.length; i++) {
                const round = rounds[i];
                
            // Inoffizielles HCP nach dieser Runde (WHS-KORREKT!)
            // Berechne mit allen Runden bis zu diesem Zeitpunkt
            const tempAllRounds = myGolfer.rounds
                .filter(r => new Date(r.date) <= new Date(round.date))
                .slice(-20)
                .map(r => ({ id: r.id, sd: r.scoreDifferential }))
                .sort((a, b) => a.sd - b.sd);
            
            if (tempAllRounds.length === 0) {
                unofficialHistory.push(myGolfer.startHcp);
            } else if (tempAllRounds.length < 3) {
                // Bei <3 Runden: Start-HCP
                unofficialHistory.push(myGolfer.startHcp);
            } else {
                // WHS-Regeln anwenden
                const count = tempAllRounds.length;
                let numCounted, adjustment;
                
                // WHS-Parameter bestimmen
                if (count >= 3 && count <= 4) {
                    numCounted = 1;
                    adjustment = count === 3 ? -2.0 : -1.0;
                } else if (count === 5) {
                    numCounted = 1;
                    adjustment = 0;
                } else if (count === 6) {
                    numCounted = 2;
                    adjustment = -1.0;
                } else if (count >= 7 && count <= 8) {
                    numCounted = 2;
                    adjustment = 0;
                } else if (count >= 9 && count <= 11) {
                    numCounted = 3;
                    adjustment = 0;
                } else if (count >= 12 && count <= 14) {
                    numCounted = 4;
                    adjustment = 0;
                } else if (count >= 15 && count <= 16) {
                    numCounted = 5;
                    adjustment = 0;
                } else if (count >= 17 && count <= 18) {
                    numCounted = 6;
                    adjustment = 0;
                } else if (count === 19) {
                    numCounted = 7;
                    adjustment = 0;
                } else {
                    numCounted = 8;
                    adjustment = 0;
                }
                
                const bestRounds = tempAllRounds.slice(0, numCounted);
                let newHcp = bestRounds.reduce((a, b) => a + b.sd, 0) / numCounted;
                
                // Soft Cap anwenden
                const lowestHcp = (typeof myGolfer.lowestHandicapIndex === 'number') ? myGolfer.lowestHandicapIndex : myGolfer.startHcp;
                newHcp = Math.min(newHcp, lowestHcp + 3.0);

                // Adjustment anwenden
                newHcp += adjustment;

                unofficialHistory.push(Math.round(newHcp * 10) / 10);
                }
                
            // Offizielles HCP nach dieser Runde (WHS-KORREKT!)
            const tempOfficialRounds = myGolfer.rounds
                .filter(r => r.official !== false && new Date(r.date) <= new Date(round.date))
                .slice(-20)
                .map(r => ({ id: r.id, sd: r.scoreDifferential }))
                .sort((a, b) => a.sd - b.sd);
            
            if (tempOfficialRounds.length === 0) {
                officialHistory.push(myGolfer.startHcp);
            } else if (tempOfficialRounds.length < 3) {
                // Bei <3 Runden: Start-HCP
                officialHistory.push(myGolfer.startHcp);
            } else {
                // WHS-Regeln anwenden
                const count = tempOfficialRounds.length;
                let numCounted, adjustment;
                
                // WHS-Parameter direkt berechnen
                if (count >= 3 && count <= 4) {
                    numCounted = 1;
                    adjustment = count === 3 ? -2.0 : -1.0;
                } else if (count === 5) {
                    numCounted = 1;
                    adjustment = 0;
                } else if (count === 6) {
                    numCounted = 2;
                    adjustment = -1.0;
                } else if (count >= 7 && count <= 8) {
                    numCounted = 2;
                    adjustment = 0;
                } else if (count >= 9 && count <= 11) {
                    numCounted = 3;
                    adjustment = 0;
                } else if (count >= 12 && count <= 14) {
                    numCounted = 4;
                    adjustment = 0;
                } else if (count >= 15 && count <= 16) {
                    numCounted = 5;
                    adjustment = 0;
                } else if (count >= 17 && count <= 18) {
                    numCounted = 6;
                    adjustment = 0;
                } else if (count === 19) {
                    numCounted = 7;
                    adjustment = 0;
                } else {
                    numCounted = 8;
                    adjustment = 0;
                }
                
                const bestRounds = tempOfficialRounds.slice(0, numCounted);
                let newHcp = bestRounds.reduce((a, b) => a + b.sd, 0) / numCounted;

                // Soft Cap anwenden
                const lowestHcp = (typeof myGolfer.lowestHandicapIndex === 'number') ? myGolfer.lowestHandicapIndex : myGolfer.startHcp;
                newHcp = Math.min(newHcp, lowestHcp + 3.0);

                // Adjustment anwenden
                newHcp += adjustment;

                officialHistory.push(Math.round(newHcp * 10) / 10);
            }
                }
            
            if (unofficialHistory.length > 0) {
                unofficialHistory[unofficialHistory.length - 1] = myGolfer.unofficialHandicap;
            }
            if (officialHistory.length > 0) {
                officialHistory[officialHistory.length - 1] = myGolfer.handicapIndex;
            }
               
            // Finde min/max f√ºr Y-Achse
            const allValues = [...unofficialHistory, ...officialHistory];
            const maxHcp = Math.ceil(Math.max(...allValues));
            const minHcp = Math.floor(Math.min(...allValues));
            const range = maxHcp - minHcp || 1;
            
            ctx.clearRect(0, 0, cssW, cssH);
            
            // Zeichne Hintergrund-Gitter und Y-Achsen-Labels
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            
            const steps = Math.min(5, range + 1);
            for (let i = 0; i <= steps; i++) {
                const hcpValue = minHcp + (range * i / steps);
                const y = padding.top + chartHeight - (chartHeight * i / steps);
                
                // Horizontale Gitterlinie
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(cssW - padding.right, y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Y-Achsen-Label
                ctx.fillText(hcpValue.toFixed(1), padding.left - 10, y + 4);
            }
            
            // Hilfsfunktion: HCP-Wert zu Y-Koordinate
            const hcpToY = (hcp) => {
                return padding.top + chartHeight - ((hcp - minHcp) / range) * chartHeight;
            };
            
            // Zeichne OFFIZIELLES HCP (Gr√ºn, dick, durchgezogen)
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 3.5;
            ctx.setLineDash([]);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            officialHistory.forEach((hcp, i) => {
                const x = padding.left + (i / (rounds.length - 1)) * chartWidth;
                const y = hcpToY(hcp);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Zeichne INOFFIZIELLES HCP (Grau, normal, durchgezogen)
            ctx.strokeStyle = '#6c757d';
            ctx.lineWidth = 2.5;
            
            ctx.beginPath();
            unofficialHistory.forEach((hcp, i) => {
                const x = padding.left + (i / (rounds.length - 1)) * chartWidth;
                const y = hcpToY(hcp);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Zeichne Punkte NUR bei tats√§chlich gespielten Runden
            rounds.forEach((round, i) => {
                const x = padding.left + (i / (rounds.length - 1)) * chartWidth;
                
                // Offiziell gespielt? ‚Üí Gr√ºner Punkt
                if (round.official !== false) {
                    const y = hcpToY(officialHistory[i]);
                    ctx.fillStyle = '#28a745';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Inoffiziell gespielt? ‚Üí Grauer Punkt
                if (round.official === false) {
                    const y = hcpToY(unofficialHistory[i]);
                    ctx.fillStyle = '#6c757d';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Legende
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            
            // Gr√ºne Linie
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(padding.left, cssH - 24);
            ctx.lineTo(padding.left + 20, cssH - 24);
            ctx.stroke();
            ctx.fillStyle = '#28a745';
            ctx.fillText('Offiziell', padding.left + 25, cssH - 20);

            // Graue Linie
            ctx.strokeStyle = '#6c757d';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(padding.left + 120, cssH - 24);
            ctx.lineTo(padding.left + 140, cssH - 24);
            ctx.stroke();
            ctx.fillStyle = '#6c757d';
            ctx.fillText('Inoffiziell', padding.left + 145, cssH - 20);

        }
        
            function addCourse() {
                const name = document.getElementById('courseName').value.trim();
                const cr = parseFloat(document.getElementById('courseCR').value);
                const sr = parseInt(document.getElementById('courseSR').value);
                const holes = parseInt(document.querySelector('input[name="courseHoles"]:checked').value);
                const par = parseInt(document.getElementById('coursePar').value) || (holes === 9 ? 36 : 72);
                
                if (!name || isNaN(cr) || isNaN(sr) || cr < 20 || sr < 55 || sr > 155) {
                    return alert('Bitte korrekte Platzdaten eingeben! (CR min. 20, SR 55-155)');
                }
                
                courses.push({
                    id: Date.now().toString(),
                    name: name,
                    cr: cr,
                    sr: sr,
                    holes: holes,
                    par: par
                });

        
                saveCourses();
                updateUI();
                
                document.getElementById('courseName').value = '';
                document.getElementById('courseCR').value = '';
                document.getElementById('courseSR').value = '';
                document.getElementById('coursePar').value = '';

                
                alert(`${name} wurde gespeichert!`);
            }
    
  
              function editCourse(courseId) {
                const course = courses.find(c => c.id === courseId);
                if (!course) return;
            
                const oldName = course.name;
                const newName = prompt('Platzname √§ndern:', course.name);
                if (newName === null) return;
            
                const newCR = prompt('Course Rating √§ndern:', course.cr);
                if (newCR === null) return;
            
                const newSR = prompt('Slope Rating √§ndern:', course.sr);
                if (newSR === null) return;
            
                const newHoles = prompt('Lochzahl √§ndern (9 oder 18):', course.holes || 18);
                if (newHoles === null) return;
            
                const holes = parseInt(newHoles);
                if (holes !== 9 && holes !== 18) {
                    return alert('Lochzahl muss 9 oder 18 sein!');
                }
                  
                const newPar = prompt('Par √§ndern:', course.par || (holes === 9 ? 36 : 72));
                if (newPar === null) return;
                  
                const par = parseInt(newPar);
                if (isNaN(par) || par < 27 || par > 90) {
                    return alert('Par muss zwischen 27 und 90 liegen!');
                }
                  
                const cr = parseFloat(newCR);
                const sr = parseInt(newSR);
            
                if (!newName.trim() || isNaN(cr) || isNaN(sr) || cr < 20 || sr < 55 || sr > 155) {
                    return alert('Ung√ºltige Eingaben! (CR min. 20, SR 55-155)');
                }
            
                const oldCR = course.cr;
                        const oldSR = course.sr;
                        const oldHoles = course.holes || 18;
                
                        course.name = newName.trim();
                        course.cr = cr;
                        course.sr = sr;
                        course.holes = holes;
                        course.par = par;
                
                        const usedInRounds = myGolfer.rounds.filter(r => r.course === oldName && r.holes === oldHoles);
                  
                if (usedInRounds.length > 0) {
                        const nameChanged = oldName !== newName.trim();
                        const holesChanged = oldHoles !== holes;
                        if (nameChanged || holesChanged) {
                            const changes = [];
                            if (nameChanged) changes.push('Name');
                            if (holesChanged) changes.push('Lochzahl');
                            if (confirm(`${usedInRounds.length} Runden verwenden diesen Platz. ${changes.join(' und ')} in allen Runden aktualisieren?`)) {
                                usedInRounds.forEach(round => {
                                    if (nameChanged) round.course = newName.trim();
                                    if (holesChanged) round.holes = holes;
                                });
                            }
                        }
            
            if (oldCR !== cr || oldSR !== sr) {
                // Neuberechnung muss mit den tats√§chlichen Rundendaten matchen
                // Falls Name/Holes NICHT aktualisiert wurden, tempor√§r zur√ºcksetzen
                const savedName = course.name;
                const savedHoles = course.holes;
                // Finde Runden mit den Werten die sie tats√§chlich haben
                const roundsToRecalc = myGolfer.rounds.filter(r => 
                    (r.course === savedName && r.holes === savedHoles) ||
                    (r.course === oldName && r.holes === oldHoles)
                );
                roundsToRecalc.forEach(round => {
                    let newSD;
                    if (round.holes === 9) {
                        const sd_9_played = ((round.strokes - cr) * (113 / sr));
                        const currentHCPI = myGolfer.handicapIndex !== undefined ? myGolfer.handicapIndex : myGolfer.startHcp;
                        const sd_9_expected = ((currentHCPI * 1.04) + 2.4) / 2;
                        newSD = parseFloat((sd_9_played + sd_9_expected).toFixed(1));
                    } else {
                        newSD = parseFloat(((round.strokes - cr) * (113 / sr)).toFixed(1));
                    }
                    round.cr = cr.toFixed(1);
                    round.sr = sr.toFixed(0);
                    round.scoreDifferential = newSD;
                });
                updateMyHandicap();
                updateUnofficialHandicap();
                localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
                saveCourses();
                updateUI();
                alert(`Platz wurde aktualisiert!\n${roundsToRecalc.length} Runden wurden mit neuen CR/SR-Werten neu berechnet.\nHandicap wurde aktualisiert.`);
                return;
            }
                    localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
                }
            
                saveCourses();
                updateUI();
                alert('Platz wurde aktualisiert!');
            }

        function deleteCourse(courseId) {
            const course = courses.find(c => c.id === courseId);
            if (!course) return;
            
            const usedInRounds = myGolfer.rounds.some(r => r.course === course.name);
            
            let confirmMsg = `Platz "${course.name}" wirklich l√∂schen?`;
            if (usedInRounds) {
                confirmMsg += '\n\n‚ö†Ô∏è ACHTUNG: Dieser Platz wurde bereits in Runden verwendet.\nDie Runden bleiben erhalten, aber der Platzname kann nicht mehr bearbeitet werden.';
            }
            
            if (!confirm(confirmMsg)) return;
            
            courses = courses.filter(c => c.id !== courseId);
            saveCourses();
            updateUI();
            alert('‚úÖ Platz wurde gel√∂scht!');
        }
        
        function showEditProfile() {
            const newName = prompt('Name √§ndern:', myGolfer.name);
            if (newName && newName.trim()) {
                myGolfer.name = newName.trim();
            }
            
            const newClub = prompt('Club √§ndern:', myGolfer.club);
            if (newClub !== null) {
                myGolfer.club = newClub.trim();
            }
            
        const newHcp = prompt('Handicap manuell setzen:', myGolfer.handicapIndex);
                if (newHcp !== null && !isNaN(newHcp)) {
                    const hcpValue = parseFloat(newHcp);
                    
                    myGolfer.handicapIndex = hcpValue;
                    myGolfer.unofficialHandicap = hcpValue;
                    if (typeof myGolfer.lowestHandicapIndex === 'number') {
                        myGolfer.lowestHandicapIndex = Math.min(myGolfer.lowestHandicapIndex, hcpValue);
                    } else {
                        myGolfer.lowestHandicapIndex = hcpValue;
                    }
                }
            
            localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
            updateUI();
            alert('‚úÖ Profil aktualisiert!');
        }
        
        function exportData() {
            const data = {
                golfer: myGolfer,
                courses: courses,
                exportDate: new Date().toISOString().split('T')[0],
                appVersion: '2.1'
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mein-golf-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('‚úÖ Daten wurden exportiert!');
        }
        
            function importData(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        // Validierung zuerst
                        if (!data.golfer || !data.golfer.rounds || !Array.isArray(data.golfer.rounds)) {
                            throw new Error('Ung√ºltiges Datenformat');
                        }
                        // Daten erst jetzt speichern
                        myGolfer = data.golfer;
                        courses = data.courses || [];
                        localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
                        saveCourses();
                        checkSetup();
                        alert('‚úÖ Import erfolgreich!\n\n' + myGolfer.rounds.length + ' Runden wurden geladen.');
                    } catch(err) {
                        alert('‚ùå Import-Fehler: ' + err.message);
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }
        
        function setupImportData(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    // Validierung zuerst!
                    if (!data.golfer || !data.golfer.rounds || !Array.isArray(data.golfer.rounds)) {
                        throw new Error('Ung√ºltiges Datenformat: "golfer.rounds" fehlt oder ist kein Array.');
                    }
                    // ERST HIER die globalen Variablen aktualisieren
                    myGolfer = data.golfer;
                    courses = data.courses || [];
                    localStorage.setItem('myGolfer', JSON.stringify(myGolfer));
                    saveCourses();
                    // DANACH erst die UI neu initialisieren
                    alert('‚úÖ Import erfolgreich!\n\n' + myGolfer.rounds.length + ' Runden wurden geladen.');
                    checkSetup();
                } catch(err) {
                    // FEHLERFALL: myGolfer und courses wurden NICHT ver√§ndert
                    console.error("Setup Import failed:", err);
                    alert('‚ùå Import-Fehler: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Input zur√ºcksetzen
        }
        
        function showHandicapCalculation() {
            // 1. Hole alle offiziellen Runden (max. 20, sortiert nach Score Differential)
            const officialRounds = myGolfer.rounds
                .filter(r => r.official !== false)
                .slice(-20)
                .map(r => ({ 
                    id: r.id,
                    date: r.date, 
                    course: r.course, 
                    holes: r.holes,
                    strokes: r.strokes,
                    sd: r.scoreDifferential,
                    playingHcp: r.playingHcp
                }))
                .sort((a, b) => a.sd - b.sd);
        
            if (officialRounds.length === 0) {
                alert("Keine offiziellen Runden vorhanden!\n\nDein Handicap basiert auf dem Startwert: " + myGolfer.startHcp.toFixed(1));
                return;
            }
        
            const count = officialRounds.length;
            
            // Bei weniger als 3 Runden: Start-HCP bleibt
            if (count < 3) {
                alert(`WHS HANDICAP-BERECHNUNG\n\nDu hast erst ${count} offizielle Runde${count > 1 ? 'n' : ''}.\n\nMindestens 3 Runden sind n√∂tig f√ºr die Berechnung.\nBis dahin gilt dein Start-Handicap: ${myGolfer.startHcp.toFixed(1)}`);
                return;
            }
        
            // 2. WHS-Parameter: Wie viele Runden werden gewertet?
            const { numCounted, adjustment } = getWHSParameters(count);
            const countedRounds = officialRounds.slice(0, numCounted);
            const countedIds = countedRounds.map(r => r.id);
            
            // 3. Berechne Durchschnitt der besten Runden
            let avgBest = countedRounds.reduce((a, b) => a + b.sd, 0) / numCounted;
            
            // 4. Soft Cap: Begrenze auf beste SD + 3
            const lowestHcp = (typeof myGolfer.lowestHandicapIndex === 'number') ? myGolfer.lowestHandicapIndex : myGolfer.handicapIndex;
            const softCapLimit = lowestHcp + 3.0;
            const beforeCap = avgBest;
            avgBest = Math.min(avgBest, softCapLimit);
            const softCapApplied = beforeCap > softCapLimit;
            
            // 5. Adjustment (Bonus/Anpassung) anwenden
            let calculatedHcp = avgBest + adjustment;
            
            // 6. Hard Cap: HCP darf nie mehr als 5.0 √ºber dem besten Wert liegen
            const lowIndex = (typeof myGolfer.lowestHandicapIndex === 'number') ? myGolfer.lowestHandicapIndex : calculatedHcp;
            const hardCapLimit = lowIndex + 5.0;
            const beforeHardCap = calculatedHcp;
            calculatedHcp = Math.min(calculatedHcp, hardCapLimit);
            const hardCapApplied = beforeHardCap > hardCapLimit;
            
            // 7. Runde auf 0.1
            const finalHcp = Math.round(calculatedHcp * 10) / 10;
        
            // 8. Finde die Runden die als n√§chstes "rausfallen"
            const allOfficialByDate = myGolfer.rounds
                .filter(r => r.official !== false)
                .slice(-20)
                .sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const nextToFallOut = allOfficialByDate.length >= 20 ? [allOfficialByDate[0]] : [];
            const fallOutIds = nextToFallOut.map(r => r.id);
        
            // === TEXT ERSTELLEN ===
            let msg = "WHS HANDICAP-BERECHNUNG\n";
            msg += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
            
            // √úbersicht
            msg += `Offizielle Runden (letzte 20): ${count}\n`;
            msg += `Davon gewertet (beste): ${numCounted}\n`;
            if (adjustment !== 0) {
                msg += `WHS-Anpassung: ${adjustment > 0 ? '+' : ''}${adjustment.toFixed(1)}\n`;
            }
            msg += "\n";
        
            // Schritt 1: Gewertete Runden
            msg += "GEWERTETE RUNDEN\n";
            msg += "Die besten Runden z√§hlen f√ºr dein HCP:\n\n";
            
            countedRounds.forEach((r, i) => {
                // Finde Platzinfo f√ºr zu-Par-Berechnung
                const course = courses.find(c => c.name === r.course && c.holes === r.holes);
                const par = course ? course.par : (r.holes === 9 ? 36 : 72);
                const toPar = r.strokes - par;
                const toParText = toPar > 0 ? `+${toPar}` : toPar.toString();
                
                msg += `${i + 1}. ${r.date} ‚Ä¢ ${r.course}\n`;
                msg += `   ${r.strokes} Schl√§ge (${toParText} zu Par) ‚Ä¢ SD ${r.sd.toFixed(1)}\n`;
            });
            
            msg += "\n";
            msg += `Durchschnitt: ${beforeCap.toFixed(1)}\n`;
            
            // Soft Cap
            if (softCapApplied) {
                msg += `Soft Cap angewendet (max. ${softCapLimit.toFixed(1)})\n`;
            }
            
            // Adjustment
            if (adjustment !== 0) {
                msg += `WHS-Anpassung: ${adjustment > 0 ? '+' : ''}${adjustment.toFixed(1)}\n`;
            }
            
            // Hard Cap
            if (hardCapApplied) {
                msg += `Hard Cap angewendet (max. ${hardCapLimit.toFixed(1)})\n`;
            }
            
            msg += "\n";
            msg += `DEIN HANDICAP: ${finalHcp.toFixed(1)}\n`;
            msg += "\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
        
            // Schritt 2: Nicht gewertete Runden
            const notCounted = officialRounds.filter(r => !countedIds.includes(r.id));
            if (notCounted.length > 0) {
                msg += "WEITERE RUNDEN (nicht gewertet)\n";
                msg += "Diese Runden sind in der Berechnung, z√§hlen aber nicht:\n\n";
                
                notCounted.slice(0, 12).forEach(r => {
                    const course = courses.find(c => c.name === r.course && c.holes === r.holes);
                    const par = course ? course.par : (r.holes === 9 ? 36 : 72);
                    const toPar = r.strokes - par;
                    const toParText = toPar > 0 ? `+${toPar}` : toPar.toString();
                    
                    // Markiere ob Runde bald rausf√§llt
                    const willFallOut = fallOutIds.includes(r.id);
                    const marker = willFallOut ? "‚ö†" : "‚Ä¢";
                    
                    msg += `${marker} ${r.date} ‚Ä¢ ${r.course} ‚Ä¢ SD ${r.sd.toFixed(1)}\n`;
                });
                
                if (notCounted.length > 12) {
                    msg += `\n... und ${notCounted.length - 12} weitere\n`;
                }
                
                msg += "\n‚ö† = f√§llt bei n√§chster Runde raus\n";
            }
        
            alert(msg);
        }


        
        function clearData() {
            if (confirm('üö® WIRKLICH ALLES L√ñSCHEN?\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) {
                if (confirm('Letzte Best√§tigung: Alle Daten werden unwiderruflich gel√∂scht!')) {
                    localStorage.clear();
                    location.reload();
                }
            }
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            init();
            
            // iOS Safari Installationshinweis
            if (isIOS() && !isInStandaloneMode()) {
                setTimeout(() => {
                    showIOSInstallPrompt();
                }, 2000);
            }
        });
        
        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }
        
        function isInStandaloneMode() {
            return window.navigator.standalone === true || window.matchMedia('(display-mode: standalone)').matches;
        }
        
        function scrollToAddRound() {
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                sidebar.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }
        }

        function showIOSInstallPrompt() {
            const lastShown = localStorage.getItem('iosInstallPromptShown');
            const now = new Date().getTime();
            
            // Zeige maximal alle 7 Tage
            if (lastShown && (now - parseInt(lastShown)) < 7 * 24 * 60 * 60 * 1000) {
                return;
            }
            
            const showPrompt = confirm(
                'üì± INSTALLIERE DIESE APP\n\n' +
                'F√ºr die beste Erfahrung f√ºge diese App zu deinem Home-Bildschirm hinzu!\n\n' +
                '1. Tippe auf das Teilen-Symbol (unten in Safari)\n' +
                '2. Scrolle nach unten\n' +
                '3. W√§hle "Zum Home-Bildschirm"\n' +
                '4. Tippe auf "Hinzuf√ºgen"\n\n' +
                'M√∂chtest du diese Anleitung sp√§ter noch einmal sehen?'
            );
            
            if (!showPrompt) {
                localStorage.setItem('iosInstallPromptShown', now.toString());
            }
        }

        // Chart bei Fenstergr√∂√üen√§nderung neu zeichnen
        window.addEventListener('resize', function() {
            if (myGolfer && myGolfer.rounds.length >= 2) {
                renderChart();
            }
        });

    </script>
</body>
</html>
